schema {
  query: RootQuery
  mutation: RootMutation
  subscription: RootSubscription
}

"""An ECS object storage cluster instance"""
type ObjectStore implements Node {
  """Amount of storage ingested over a query window"""
  StorageIngest(
    """Number of seconds to query for storage usage"""
    last: Int = 86400
  ): Quantity
  """Returns a list of object store alert policies"""
  alertPolicies(after: String, first: Int, last: Int, policyName: FilterStringArgument, offset: Int, sort: AlertPolicySort, before: String): AlertPolicyConnection
  """Returns a list of ObjectScale buckets"""
  buckets(sort: BucketSort, first: Int, last: Int, tenantID: String, name: FilterStringArgument, encryptionEnabled: FilterBooleanArgument, retention: FilterIntegerArgument, auditDeleteExpiration: FilterIntegerArgument, creationTime: FilterDateTimeArgument, defaultRetention: FilterIntegerArgument, offset: Int, before: String, after: String): BucketConnection
  """Capacity information for the object store"""
  capacity: Capacity
  """Returns a list of cluster nodes"""
  clusterNodes(
    name: FilterStringArgument
    """The source of the label"""
    source: String
    sort: ClusterNodeSort
    last: Int
    first: Int
    """The value of the label"""
    value: String
    """The fault domain source"""
    faultDomainSource: String
    """
    List of node hostnames (kubernetes.io/hostname label) to be excluded from resource scheduling
    """
    excludedNodes: [String]
    before: String
    available: FilterBooleanArgument
    """The key of the label"""
    key: String
    offset: Int
    role: FilterStringArgument
    """The fault domain key"""
    faultDomainKey: String
    after: String
  ): ClusterNodeConnection
  """Return a list of kubernetes deployments"""
  deployments(availableReplicas: FilterIntegerArgument, updatedReplicas: FilterIntegerArgument, sort: DeploymentSort, after: String, replicas: FilterIntegerArgument, namespace: FilterStringArgument, readyReplicas: FilterIntegerArgument, unavailableReplicas: FilterIntegerArgument, offset: Int, last: Int, before: String, first: Int, name: FilterStringArgument): DeploymentConnection
  """
  Rule to apply on an event to select the list of Notifiers where the event will be sent
  """
  eventRules: [EventRule]
  """Return a list events"""
  events(resourceID: FilterStringArgument, offset: Int, after: String, symptomID: FilterStringArgument, message: FilterStringArgument, applicationName: FilterStringArgument, count: Int, sort: EventSort, before: String, first: Int, last: Int, type: FilterStringArgument, createdOn: FilterDateTimeArgument, updatedOn: FilterDateTimeArgument, namespace: FilterStringArgument, acknowledged: FilterBooleanArgument, component: FilterStringArgument, reason: FilterStringArgument): EventConnection
  """Returns a list of federated object stores"""
  federatedObjectStores(first: Int, pauseStartMills: FilterIntegerArgument, suspendStartMills: FilterIntegerArgument, failedDataGiB: FilterIntegerArgument, after: String, replicationStatus: FilterStringArgument, replicationConfigured: FilterBooleanArgument, objectStoreRTO: FilterIntegerArgument, pauseEndMills: FilterIntegerArgument, offset: Int, sort: ObjectStoreSort, before: String, last: Int, objectScaleID: FilterStringArgument, objectStoreID: FilterStringArgument, objectStoreName: FilterStringArgument, throttledMbPerSecond: FilterIntegerArgument): FederatedObjectStoreConnection
  """
  Generates a log bundle for the manager components, and returns a URL to download
  """
  generateLogBundle: String
  """User provided group used for logical organization"""
  group: String
  """Counts for health checks of an object store"""
  healthCheckCounts(groups: [String]): Counts
  """Checks to determine the health of the object store"""
  healthChecks: [HealthInfo]
  """
  Indicates if the volumes provisioned for object store will survive a node outage
  """
  highlyAvailableVolumes: Boolean
  """The ID of an object"""
  id: ID!
  """Return a list application health issues"""
  issues(applicationName: FilterStringArgument, offset: Int, after: String, createdOn: FilterDateTimeArgument, updatedOn: FilterDateTimeArgument, last: Int, component: FilterStringArgument, message: FilterStringArgument, namespace: FilterStringArgument, sort: IssueSort, acknowledged: FilterBooleanArgument, before: String, first: Int, symptomID: FilterStringArgument, type: FilterStringArgument, clearType: FilterStringArgument, resourceID: FilterStringArgument, reason: FilterStringArgument): IssueConnection
  """Return a list of kubernetes resources"""
  kubernetesResources(namespace: FilterStringArgument, sizeResource: FilterStringArgument, kind: FilterStringArgument, readiness: FilterStringArgument, offset: Int, sort: KubernetesResourceSort, after: String, name: FilterStringArgument, first: Int, last: Int, before: String, creationTimestamp: FilterDateTimeArgument): KubernetesResourcesConnection
  """Labels applied on object store application resource"""
  labels: [label]
  """Read and write latency statistics for this object store"""
  latency(
    """Frame start time for performance data selection (RFC 3339 format)"""
    start: DateTime
    """Frame end time for performance data selection (RFC 3339 format)"""
    end: DateTime
  ): Latency
  """The configured log receiver for this object store"""
  logReceiver: LogReceiverConfig
  """The installer mode used for installing Object Store"""
  managedBy: String
  """The connection details of the management API"""
  managementConnection: NetworkConnection
  """URL for the object store management API"""
  managementEndpoint: String
  """Bucket and object level statistics for this object store"""
  metering(
    """TenantID used to identify the bucket namespace"""
    tenantID: String
  ): Metering
  """Name of the object store"""
  name: String
  """Kubernetes namespace of the object store"""
  namespace: String
  """Returns a list of non deleted federated object stores"""
  nonDeletedFederatedObjectStores(replicationStatus: FilterStringArgument, pauseStartMills: FilterIntegerArgument, throttledMbPerSecond: FilterIntegerArgument, sort: FederatedObjectStoreSort, before: String, replicationConfigured: FilterBooleanArgument, suspendStartMills: FilterIntegerArgument, failedDataGiB: FilterIntegerArgument, after: String, objectStoreID: FilterStringArgument, objectStoreName: FilterStringArgument, last: Int, first: Int, objectScaleID: FilterStringArgument, pauseEndMills: FilterIntegerArgument, objectStoreRTO: FilterIntegerArgument, offset: Int): NonDeletedFederatedObjectStoreConnection
  """Post-installation notes of the object store"""
  notes: String
  """Current state of the object store"""
  objectStoreState: String
  """Returns a list of ObjectScale objectUsers"""
  objectUsers(offset: Int, sort: ObjectUserSort, last: Int, before: String, after: String, first: Int, accessKey: FilterStringArgument): ObjectUserConnection
  """Returns a list of Kubernetes persistent volume claims"""
  persistentVolumeClaims(name: FilterStringArgument, capacityInMB: FilterIntegerArgument, volumeName: FilterStringArgument, storageClassName: FilterStringArgument, volumeMode: FilterStringArgument, offset: Int, sort: PersistentVolumeClaimSort, before: String, after: String, first: Int, last: Int): PersistentVolumeClaimConnection
  """Return a list of Kubernetes persistent volumes"""
  persistentVolumes(reason: FilterStringArgument, sort: PersistentVolumeSort, before: String, after: String, status: FilterStringArgument, storageClassName: FilterStringArgument, offset: Int, last: Int, capacity: FilterStringArgument, reclaimPolicy: FilterStringArgument, name: FilterStringArgument, claimName: FilterStringArgument, message: FilterStringArgument, createdTimestamp: FilterDateTimeArgument, first: Int): PersistentVolumeConnection
  """The current state of the object store"""
  phase: String
  """Return a list of Kubernetes pods"""
  pods(namespace: FilterStringArgument, IP: FilterStringArgument, CPURequestInMilli: FilterStringArgument, CPULimitInMilli: FilterStringArgument, offset: Int, last: Int, node: FilterStringArgument, sort: PodSort, before: String, name: FilterStringArgument, MemoryLimitInKB: FilterStringArgument, after: String, first: Int, status: FilterStringArgument, MemoryRequestInKB: FilterStringArgument): PodConnection
  """
  Object store profile used for to attain capacity, concurrency and/orperformance requirements
  """
  profile: Profile
  """
  A string representation of the components currently available, or the phase of execution for the object store
  """
  readyComponents: String
  """Returns information about ObjectScale instances"""
  rebuildProgress: Float
  """The number of storage instances used in an object store"""
  replicas: Int
  """The connection details of the Geo Receiver API"""
  replicationConnection: NetworkConnection
  """URL for the object store replication data API"""
  replicationSecureEndpoint: String
  """Provisioned resource for this object store"""
  resources: ResourceProvision
  """The connection details of the s3 API"""
  s3Connection: NetworkConnection
  """URL for the object store s3 data API"""
  s3SecureEndpoint: String
  """Returns a list of Kubernetes services"""
  services(namespace: FilterStringArgument, before: String, first: Int, last: Int, name: FilterStringArgument, serviceType: ServiceServiceType, clusterIP: FilterStringArgument, offset: Int, sort: FilterStringArgument, after: String): ServiceConnection
  """The customer provided inputs when sizing the object store"""
  sizingInputs: SizingInput
  """The sizer generated outputs from a customer sizing request"""
  sizingOutputs: SizingOutput
  spec: ObjectStoreSpec
  """Current state of the object store"""
  state: String @deprecated(reason: "Deprecated please use the field objectStoreState  in future queries.")
  """Return a list of Kubernetes statefulset"""
  statefulSets(replicas: FilterStringArgument, offset: Int, sort: StatefulSetSort, after: String, namespace: FilterStringArgument, labels: FilterStringArgument, first: Int, last: Int, before: String, name: FilterStringArgument): StatefulSetConnection
  """The configured storage topology for this object store"""
  storageTopology: StorageTopologyConfig
  """The Kubernetes storageclass used for stream data"""
  streamDataStorageClass: StorageClass
  """The Kubernetes storageclass used for control and discovery metadata"""
  systemDataStorageClass: StorageClass
  """The name of the template used to create this object store"""
  template: String
  """Returns a list of object store tenants"""
  tenants(before: String, after: String, first: Int, last: Int, tenantID: FilterStringArgument, alias: FilterStringArgument, offset: Int, sort: TenantSort): TenantConnection
  """
  During a transition this field will show a number from 0-99 signifying progress in reaching the next target state
  """
  transitionPercentageComplete: Int
  upgradesAvailable: [String]
  """Resource utilization metrics for this object store"""
  usage: ResourceUsage
  """The Kubernetes storageclass used for user data and metadata"""
  userDataStorageClass: StorageClass
  """Software revision of the installed package"""
  version: String
}

"""Kubernetes Storage Class type for sizing input"""
input SizingInputStorageClassInput {
  """The pool type backing this storage class"""
  poolType: String!
  """Name of the Kubernetes storage class"""
  name: String!
  """
  Indicates that the storage class provisions volumes local to a single host
  """
  hostLocal: Boolean!
}

type CertificateTemplateType {
  """The certificate to upload"""
  certificate: String
  """The name of certificate to upload"""
  certificateName: String
  """The password attached to the certificate (optional)"""
  certificatePassword: String
  """The intermediate certificate authority (optional)"""
  intermediateCA: String
  """
  The private key that corresponds with the public key in the certificate
  """
  privateKey: String
  """The root certificate authority (optional)"""
  rootCA: String
}

input NamespacedNameInput {
  """Name of the object"""
  name: String!
  """Namespace of the object"""
  namespace: String!
}

"""A kubernetes event rule"""
input EventRuleInputType {
  """event rule description"""
  description: String
  """list of criteria to select events"""
  matchon: [MatchOnInput]
  """list of notifiers to provide what apps notify"""
  notifiers: [String]
}

"""Fields sortable for bucket field"""
enum BucketSortableField {
  retention
  owner
  policy
  auditDeleteExpiration
  name
  creationTime
  defaultRetention
}

"""The replication configuration set on the bucket"""
type BucketReplicationConfigurationType {
  role: String
  rules: [ReplicationRuleType]
}

"""A connection to a list of items."""
type EventConnection {
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [EventEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

input IAMUpdateGroupInput {
  """The new path to update to"""
  newPath: String
  """The Account ID of the group to update"""
  accountID: String!
  """The group name to be updated"""
  groupName: String!
  """The updated group name when renaming the group"""
  newGroupName: String
}

input HealthCheckInputType {
  """Namespace of the application"""
  namespace: String!
  """Checks to run for the application"""
  checks: [InputCheckType]
  """Name of the application"""
  name: String!
}

"""Remove IAM user to specific IAM group"""
input RemoveUserFromGroupInput {
  """The account ID of the user"""
  accountID: String!
  """The friendly name identifying the user"""
  userName: String!
  """The name of the group to remove"""
  groupName: String!
}

"""An instance of a Helm Chart installed into a Kubernetes cluster"""
type HelmRelease implements Node {
  chartName: String
  chartVersion: String
  """Returns a list of HealthChecks"""
  healthChecks(check: String, offset: Int, before: String, after: String, first: Int, last: Int, name: FilterStringArgument, namespace: FilterStringArgument): HealthCheckConnection
  """Returns a list of Kubernetes HelmCharts"""
  helmCharts(description: FilterStringArgument, icon: FilterStringArgument, tags: FilterStringArgument, allVersions: Boolean, before: String, type: FilterStringArgument, first: Int, kubeVersion: FilterStringArgument, offset: Int, name: FilterStringArgument, sources: FilterStringListArgument, keywords: FilterStringListArgument, apiVersion: FilterStringArgument, condition: FilterStringArgument, appVersion: FilterStringArgument, sort: HelmChartSort, after: String, home: FilterStringArgument, version: FilterStringArgument, deprecated: FilterBooleanArgument, last: Int): HelmChartConnection
  """The ID of an object"""
  id: ID!
  kahmSubscribed: Boolean
  lastDeployed: DateTime
  name: String
  namespace: String
  readyComponents: String
  status: String
}

"""A connection to a list of items."""
type StoragePoolConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The field name for the summation"""
    values: [String]
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [StoragePoolEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection"""
type ObjectStoreEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: ObjectStore
}

"""Kubernetes standard resources related to Dell EMC ObjectScale"""
interface KubernetesResource {
  """Size of the resource"""
  size: Quantity
  """Type of resource used in size field"""
  sizeResource: String
  """Kubernetes resource kind"""
  kind: String
  """Name of the resource"""
  name: String
  """Namespace the resources is within"""
  namespace: String
  """Datetime that the resource was created"""
  creationTimestamp: String
  """Number of replicas available"""
  readiness: String
}

"""A single workload that may be part of an ObjectStore"""
type workload {
  """If data will be encrypted"""
  encryption: Boolean
  """Annual expected growth rate in percent for the store"""
  growthRate: Int
  """Object size for this workload"""
  objectSize: Quantity
  """Show how much capacity is needed"""
  primaryCapacity: Quantity
  """Read write ratio"""
  readWriteRatio: Int
  """How much concurrent transactions"""
  transactions: Int
  """Use case for the object store"""
  useCase: UseCaseType
}

"""An edge in a connection"""
type PolicyEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Policy
}

input ObjectStoreUpgradeInput {
  """The target upgrade version to be upgraded"""
  version: String
  """Namespaces and names of object-stores upon which to perform operation"""
  namespacedNames: [NamespacedNameInput]
}

"""A connection to a list of items."""
type StatefulSetConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The field name for the summation"""
    values: [String]
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [StatefulSetEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""License"""
type License {
  """License end date"""
  endDate: String
  """Entitlement Software ID for a given PLC"""
  enterpriseSoftwareID: String
  """List of features"""
  features: [Feature]
  """
  Amount of time the platform software should wait before enforcing the license
  """
  gracePeriod: String
  """The ID of an object"""
  id: ID!
  """Instance Software ID for a given PLC"""
  instanceSoftwareID: String
  name: String
  namespace: String
  """Capacity of the license"""
  quantity: Int
  """License start date"""
  startDate: String
  """License type"""
  type: String
}

"""An edge in a connection"""
type IAMListGroupForUserEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: IAMGroup
}

"""Changes the sort order of nodes returned in a connection"""
input AttachedPolicyEntitySort {
  """Name of field on which to sort the connection"""
  field: AttachedPolicyEntitySortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""Copy permissions of user to new user"""
input CopyPermissionsFromUserInput {
  """The account ID of the user"""
  accountID: String!
  """The friendly name identifying the user"""
  copyFromUserName: String!
  """The Username from whome to copy permissions"""
  copyToUserName: String!
}

"""Names used to sign this certificate"""
input CertificateNamesInput {
  """Organization signing this certificate"""
  organization: String
  """Organization unit (department) signing this certificate"""
  organizationalUnit: String
  """Country of origin for certificate signer"""
  country: String
  """State or province of origin for certificate signer"""
  state: String
  """Locality of origin (city, town, county, etc.) for certificate signer"""
  locality: String
}

"""An edge in a connection"""
type DeploymentEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Deployment
}

input CreateAccountAccessKeyInput {
  """A unique identifier for this account"""
  accountID: String!
}

input IAMSetDefaultPolicyVersionInput {
  """The ARN related to the IAM Policy which should have the version set"""
  ARN: String!
  """The name of the version to set"""
  PolicyVersion: String!
  """The accountID in plaintext"""
  account: String!
}

input DeleteIAMUserPolicyInput {
  """The account where resource created"""
  accountID: String!
  """The name of the user to delete"""
  userName: String!
  """The name of the policy document"""
  policyName: String!
}

"""Common configuration for Kubernetes workloads"""
type WorkloadConfig {
  """A key value pair used to tolerate """
  affinity: Affinity
  """A key value pair used to select Kubernetes nodes for a workload"""
  nodeSelector: [StringMap]
  """
  Kubernetes workload resource settings to request or limit resources used on a node
  """
  resources: Resources
  """A list of key value pairs used to tolerate specific node taints"""
  tolerations: [StringMap]
}

"""Information about installed settings"""
type SizingInput {
  """The K8S nodes available for object store scheduling"""
  clusterNodes: [ClusterNodesInput]
  """Available drive technologies"""
  driveTechnology: DriveTechnologyType
  """Indicates that type of protection scheme used for user data"""
  erasureCodingScheme: ErasureCodingSchemeType
  """List of nodes selected by user to be excluded from available resources"""
  excludedNodeList: [String]
  """Indicates that the object store is using HA volumes"""
  highlyAvailableVolumes: Boolean
  """Selected node capacity for storage server component"""
  selectedNodeCapacity: Quantity
  """Selected maximum number of replicas"""
  selectedNodeCount: Int
  """Selected performance profile"""
  selectedProfile: Profile
  """Selected volume capacity for storage server component"""
  selectedVolumeCapacity: Quantity
  """Selected number of volumes for storage server component"""
  selectedVolumeCount: Int
  """
  Projected years of growth compounded at the given GrowthRate for the store
  """
  selectedYearsOfGrowth: Int
  """List of storage pools available for this object store"""
  storagePoolList: [SizerStoragePool]
  """
  Storage class to be used for performance sensitive streaming data volumes
  """
  streamDataStorageClass: SizerStorageClass
  """Storage class to be used for performance sensitive system data volumes"""
  systemDataStorageClass: SizerStorageClass
  """Storage class to be used for user data storage server volumes"""
  userDataStorageClass: SizerStorageClass
  """All workloads that must be handled by ObjectStore"""
  workloads: [workload]!
}

"""IAM policy used to manage object stores"""
type Policy implements Node {
  """Amazon Resource Name of the policy"""
  ARN: String
  """Return a list of versions for policy"""
  PolicyVersions: PolicyVersionsConnection
  """Return a list of Entities attached to a policy"""
  attachedPolicyEntities(after: String, first: Int, entityID: FilterStringArgument, entityType: PolicyEntityType, usageType: PolicyUsageType, accountID: String, sort: AttachedPolicyEntitySort, before: String, entityName: FilterStringArgument, offset: Int, last: Int): AttachedPolicyEntityConnection
  """Number of attachments made to this policy"""
  attachmentCount: Int
  """Date on which this policy was created"""
  createDate: DateTime
  """
  The identifier for the version of the policy that is set as the default version
  """
  defaultVersionID: String
  """A longer text description of this policy"""
  description: String
  """The managed type of the policy"""
  document: String
  """The ID of an object"""
  id: ID!
  """Indicates that this policy is attachable"""
  isAttachable: Boolean
  """The friendly name (not ARN) identifying the policy"""
  name: String
  """The path to the policy"""
  path: String
  """
  The number of entities (users and roles) for which the policy is used to set the permissions boundary
  """
  permissionsBoundaryUsageCount: Int
  """Unique identifier for the policy"""
  policyID: String
  """The managed type of the policy"""
  scope: String
  """Date on which this policy was last updated"""
  updateDate: DateTime
}

input ObjectScaleNameInput {
  """The name for ObjectScale system"""
  objectScaleName: String
}

"""Values of connection objects with optional groupings"""
type Counts {
  groups: [CountGroupings]
  """Total number of edges in this connection"""
  total: Int
}

"""Fields sortable for tenant field"""
enum TenantSortableField {
  tenantID
  alias
}

input PutLegalHoldInput {
  """The version ID of the object that you want to place a Legal Hold on."""
  versionID: String
  """The key name for the object that you want to place a Legal Hold on."""
  key: String
  """The status of the field. True = enabled."""
  legalHold: Boolean
  """The bucket relay ID to put the object lock onto."""
  bucket: LegalHoldBucketConfiguration!
  """A field of acknowledgement for paid requests. """
  requestPayer: String!
}

"""the detached user policy to a resource"""
type DetachUserPolicyType {
  """Amazon Resource Name of the attached policy"""
  policyArn: String
  """The name of the user"""
  userName: String
}

input IAMUpdateRoleInput {
  """The account where resource will be updated"""
  accountID: String!
  """The name of the role that you want to modify"""
  roleName: String!
  """The updated description of the role"""
  newDescription: String
  """The updated maximum duration session (range 3600-43200)"""
  newMaxSessionDuration: Int
}

"""Changes the sort order of nodes returned in a connection"""
input PolicySort {
  """Name of field on which to sort the connection"""
  field: PolicySortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""A notifier resource"""
input NotifierInputType {
  """Hostname"""
  hostname: String
  """Namespace"""
  namespace: String
  """Name"""
  name: String
  """Port"""
  port: Int
  """GRPCConnTimeout"""
  grpcConnTimeout: Int
  """GRPCRetries"""
  grpcRetries: Int
  """TotalEventsDelivered"""
  totalEventsDelivered: Int
  """Available"""
  available: Boolean
}

"""IAM user used to manage object stores"""
input UpdateUserInput {
  """The account ID of the user"""
  accountID: String!
  """The name identifying the user"""
  userName: String!
  """The new path to the user"""
  newPath: String
  """The new name for identifying the user"""
  newUserName: String
}

"""
The `DateTime` scalar type represents a DateTime. The DateTime is serialized as an RFC 3339 quoted string
"""
scalar DateTime

"""A kubernetes service"""
type Service implements Node & KubernetesResource {
  clusterIP: String
  creationTimestamp: String
  externalIPs: [String]
  """The ID of an object"""
  id: ID!
  kind: String
  name: String
  namespace: String
  ports: [ServicePort]
  readiness: String
  serviceType: ServiceServiceType
  size: Quantity
  sizeResource: String
}

"""Changes the sort order of nodes returned in a connection"""
input RoleSort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: RoleSortableField
}

input IAMUpdateRolePolicyInput {
  """The account where resource will be updated"""
  accountID: String!
  """The name of the role that you want to modify"""
  roleName: String!
  """The updated role policy document"""
  assumeRolePolicyDocument: String!
}

input NotifierInput {
  """Name of the notifier and namespace it resides in"""
  namespacedName: NamespacedNameInput
  """The config of the notifier"""
  notifierConfig: NotifierInputType
}

"""Kubernetes Storage Class type for sizing input"""
input StorageClassInput {
  """Name of the Kubernetes storage class"""
  name: String!
  """
  Indicates that the storage class provisions volumes local to a single host
  """
  hostLocal: Boolean!
  """The pool type backing this storage class"""
  poolType: String!
}

"""A kubernetes label"""
type ClusterLabel implements Node {
  """The ID of an object"""
  id: ID!
  key: String
  nodeName: String
  source: String
  value: String
}

"""IAM account used to manage object stores"""
type Account implements Node {
  """Unique identifier for the account"""
  AccountId: String @deprecated(reason: "Use new field accountID")
  """A root user for this account"""
  AccountRootUser: String @deprecated(reason: "Use new field accountRootUser")
  """A simple name used for this account"""
  Alias: String @deprecated(reason: "Use new field alias")
  """Indicates if compliance is enabled for this account"""
  ComplianceEnabled: String @deprecated(reason: "Use new field complianceEnabled")
  """Date on which this account was created"""
  CreateDate: String @deprecated(reason: "Use new field createDate")
  """A longer text description of this account"""
  Description: String @deprecated(reason: "Use new field description")
  """Indicates if encryption is enabled for this account"""
  EncryptionEnabled: String @deprecated(reason: "Use new field encryptionEnabled")
  """ObjectScale instance with which this account is associated"""
  Objectscale: String @deprecated(reason: "Use new field objectscale")
  """Indicates if account TSO is disabled"""
  TSOId: String
  """Return a list of AccountAccessKeys"""
  accessKeys(accountID: FilterStringArgument, last: Int, before: String, after: String, first: Int): AccountAccessKeyConnection
  """Indicates if account is disabled"""
  accountDisabled: Boolean
  """Unique identifier for the account"""
  accountID: String
  """The account is created at this namespace"""
  accountNamespace: String
  """A root user for this account"""
  accountRootUser: String
  """A simple name used for this account"""
  alias: String
  """Indicates if compliance is enabled for this account"""
  complianceEnabled: Boolean
  """Date on which this account was created"""
  createDate: DateTime
  """A longer text description of this account"""
  description: String
  """Indicates if encryption is enabled for this account"""
  encryptionEnabled: Boolean
  """Return a list of IAM group"""
  groups(
    """
    The date and time, in ISO 8601 date-time format, when the group was created
    """
    createDate: FilterDateTimeArgument
    """The friendly name that identifies the group"""
    groupName: FilterStringArgument
    offset: Int
    sort: IAMGroupSort
    after: String
    first: Int
    """The Amazon Resource Name (ARN) specifying the group"""
    arn: FilterStringArgument
    """The stable and unique string identifying the group"""
    groupID: FilterStringArgument
    last: Int
    before: String
    """The path to the group"""
    path: FilterStringArgument
  ): IAMGroupConnection
  """The ID of an object"""
  id: ID!
  """The object creation delta"""
  objectCreationDelta: AccountMetrics
  """The object deletion delta"""
  objectDeletionDelta: AccountMetrics
  """ObjectScale instance with which this account is associated"""
  objectscale: String
  """Return a list of Policies"""
  policies(last: Int, first: Int, ARN: FilterStringArgument, createDate: FilterDateTimeArgument, isAttachable: FilterBooleanArgument, sort: PolicySort, attachmentCount: FilterIntegerArgument, path: FilterStringArgument, permissionsBoundaryUsageCount: FilterIntegerArgument, name: FilterStringArgument, updateDate: FilterDateTimeArgument, policyID: FilterStringArgument, scope: FilterStringArgument, offset: Int, description: FilterStringArgument, after: String, before: String, defaultVersionID: FilterStringArgument): PolicyConnection
  """The replica creation delta"""
  replicaCreationDelta: AccountMetrics
  """The replica deletion delta"""
  replicaDeletionDelta: AccountMetrics
  """Return a list of Roles"""
  roles(sort: RoleSort, first: Int, last: Int, arn: FilterStringArgument, path: FilterStringArgument, roleID: FilterStringArgument, after: String, description: FilterStringArgument, roleName: FilterStringArgument, maxSessionDuration: FilterIntegerArgument, assumeRolePolicyDocument: FilterStringArgument, createDate: FilterDateTimeArgument, offset: Int, before: String): RoleConnection
  """Return a list of IAM SAML providers"""
  samlProviders: IAMSAMLProviderConnection
  """The total replicas"""
  totalReplicas: AccountMetrics
  """The total user objects"""
  totalUserObjects: AccountMetrics
  """Return a list of Users"""
  users(before: String, createDate: FilterDateTimeArgument, path: FilterStringArgument, offset: Int, sort: UserSort, after: String, first: Int, last: Int, arn: FilterStringArgument, permissionsBoundary: FilterStringArgument, userName: FilterStringArgument): UserConnection
  """A list of webhook configurations for the account"""
  webhookConfigurations: [String]
}

input IAMCreateRoleInput {
  """The name of the role"""
  roleName: String!
  """The description of the role"""
  description: String
  """
  The maximum duration (range 3600-43200) of the session the role will have valid credentials.  (3600-43200) 
  """
  maxSessionDuration: Int
  """
  The trust relationship policy JSON document that grants an entity permission to assume the role
  """
  assumeRolePolicyDocument: String!
  """
  optional ARN of the policy that is used to set the permissions boundary for the role
  """
  permissionsBoundary: String
  """optional list of key values pairs"""
  tags: [TagInput]
  """optional path to the role"""
  path: String
  """The account where resource will be created"""
  accountID: String!
}

"""Field sortable in the Helm chart type"""
enum HelmChartSortableField {
  condition
  deprecated
  kubeVersion
  name
  home
  apiVersion
  icon
  tags
  type
  sources
  version
  description
}

"""Changes the sort order of nodes returned in a connection"""
input IssueSort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: IssueSortableField
}

"""A single k8s node available for object store scheduling"""
input ClusterNodesInputType {
  """The allocatable resources within the cluster node"""
  allocatable: SizingInputResourceInputType
  """The cluster node name"""
  name: String
}

"""A key value pair in which the key and value are both strings"""
input StringMapInputType {
  """Key used to select a Kubernetes resource"""
  key: String
  """Value used to select a Kubernetes resource"""
  value: String
}

input FedSigningInput {
  """The federation signing request (String)"""
  fedSigningRequest: String
}

type FilterRuleType {
  name: String
  value: String
}

"""Type of log receiver"""
enum LogReceiverType {
  Syslog
  Elasticsearch
}

type Webhook {
  authToken: String
  backupLimit: String
  comment: String
  endpoint: String
  name: String
}

"""A connection to a list of items."""
type IAMGroupConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [IAMGroupEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

input AttachIAMGroupPolicyInput {
  """The account id of the group"""
  accountID: String!
  """The name of the group to attach the policy"""
  groupName: String!
  """The name of the policy to attache to the user"""
  policyArn: String!
}

type RootSubscription {
  createObjectStore: ObjectStore
  upgradeObjectStores: [ObjectStore]
  upgradeRelease: HelmRelease
}

"""An edge in a connection"""
type HelmReleaseEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: HelmRelease
}

"""Fields sortable for license field"""
enum LicenseSortableField {
  enterpriseSoftwareID
  quantity
  type
  endDate
  name
  namespace
  instanceSoftwareID
  startDate
  gracePeriod
}

"""A connection to a list of items."""
type TrustedAnchorsConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The field name for the summation"""
    values: [String]
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [TrustedAnchorsEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type CountGroupings {
  """The field value used to categorize the group"""
  category: String
  """The number of edges matching this category"""
  count: Int
  """The field on which edges have been divided into categories"""
  group: String
}

"""An ECS Objectscale Services type"""
type ObjectScaleService {
  apiVersion: String
  creationTimeStamp: String
  externalDNSEndpoints: [ExternalDNSEndpoint]
  internalDNSEndpoints: [InternalDNSEndpoint]
  k8sNamespace: String
  name: String
  objectScaleId: String
  serviceScope: String
  version: String
}

type PodAffinityTerm {
  """
  Preferred affinity rules. Pod scheduling will occur even if these cannot be fulfilled
  """
  preferredDuringSchedulingIgnoredDuringExecution: [PodAffinityPreferredTerm]
  """
  Required affinity rules. Pod scheduling will remain pending until these can be fulfilled
  """
  requiredDuringSchedulingIgnoredDuringExecution: [AffinityTerm]
}

enum systemMode {
  Upgrade
  Normal
  Maintenance
  PreProduction
}

"""Object Store Template to help create a new object store"""
type ObjectStoreTemplate implements Node {
  """Geo connection for this object store template"""
  geoConnection: NetworkConnectionTemplateType
  """The ID of an object"""
  id: ID!
  """management connection for this object store template"""
  managementConnection: NetworkConnectionTemplateType
  """Object Store template name, must be unique"""
  name: String
  """s3 connection for this object store template"""
  s3Connection: NetworkConnectionTemplateType
  """Sizing Input to create the object store"""
  sizingInput: SizingInput
}

"""An edge in a connection"""
type HealthCheckEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: HealthInfo
}

"""
The replication configuration tag for the replication configuration filter
"""
type ReplicationTagType {
  key: String
  value: String
}

"""An object store alert policy instance"""
type AlertPolicy {
  condition: condition
  createdBy: String
  datapointsToAlert: Int
  datapointsToConsider: String
  isEnabled: String
  isPerInstanceMetric: String
  metricName: String
  metricType: String
  operator: String
  period: Int
  periodUnits: String
  policyName: String
  statistic: Int
}

"""Changes the sort order of nodes returned in a connection"""
input StatefulSetSort {
  """Name of field on which to sort the connection"""
  field: StatefulSetSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""Changes the sort order of nodes returned in a connection"""
input AccountSort {
  """Name of field on which to sort the connection"""
  field: AccountSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

input DetachUserPolicyInput {
  """The name of the user"""
  userName: String!
  """Amazon Resource Name of the attached policy for user"""
  policyArn: String!
  """The account ID of the user"""
  accountID: String!
}

"""Fields sortable for helmRelease field"""
enum HelmReleaseSortableField {
  name
}

"""An ECS Internal DNS Endpoint"""
type InternalDNSEndpoint {
  internalDNSEndpoint: String
}

"""Changes the sort order of nodes returned in a connection"""
input PersistentVolumeSort {
  """Name of field on which to sort the connection"""
  field: PersistentVolumeSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""An federation object store type"""
type FederatedObjectStore implements Node {
  failedDataGiB: String
  """The ID of an object"""
  id: ID!
  objectScaleID: String
  objectStoreID: String
  objectStoreName: String
  objectStoreRTO: String
  pauseEndMills: String
  pauseStartMills: String
  replicationConfigured: Boolean
  replicationStatus: String
  suspendStartMills: String
  throttledMbPerSecond: Int
}

"""Input type of log receiver"""
enum LogReceiverApplicationInputType {
  """Syslog log receiver application type"""
  Syslog
  """Elasticsearch log receiver application type"""
  Elasticsearch
}

"""Changes the sort order of nodes returned in a connection"""
input ObjectStoreSort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: ObjectStoreSortableField
}

"""An edge in a connection"""
type UserEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: User
}

"""Filter connection based comparison with string or string list argument"""
input FilterStringListArgument {
  field: [String]
  operator: Operator
  value: String
  listValue: [String]
}

"""Fields sortable for object user field"""
enum ObjectUserSortableField {
  accessKey
  creationTime
}

"""Fields sortable for inline policy field"""
enum InlinePolicySortableField {
  policyName
  policyDocument
}

input DECKSConfigInputType {
  """DECKS version"""
  version: String
  """Test SRS Gateway"""
  testSRSGateway: SRSTestGatewayInputType
  """DECKS workload config"""
  decksWorkloadConfig: WorkloadConfigInputType
}

"""Affinity rules used to direct workloads within Kubernetes cluster"""
type Affinity {
  podAffinity: PodAffinityTerm
  podAntiAffinity: PodAffinityTerm
}

"""An fed ObjectStore type"""
type FedObjectStore implements Node {
  apiVersion: String
  creationTimestamp: String
  deleted: Boolean
  """The ID of an object"""
  id: ID!
  initialized: String
  k8sNamespace: String
  objectScaleId: String
  objectStoreId: String
  objectStoreName: String
  status: String
  uid: String
  version: String
}

"""An edge in a connection"""
type NamespaceEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Namespace
}

"""Fields sortable for storage policy field"""
enum StoragePoliciesSortable {
  reconcileStatus
  storagePolicyID
  storagePolicyName
  name
  namespace
}

input PodAffinityTermInputType {
  """
  Required affinity rules. Pod scheduling will remain pending until these can be fulfilled
  """
  requiredDuringSchedulingIgnoredDuringExecution: [AffinityTermInputType]
  """
  Preferred affinity rules. Pod scheduling will occur even if these cannot be fulfilled
  """
  preferredDuringSchedulingIgnoredDuringExecution: [PodAffinityPreferredInputType]
}

input DetachRolePolicyInput {
  """The name of the role"""
  roleName: String!
  """Amazon Resource Name of the attached policy for role"""
  policyArn: String!
  """The account ID of the role"""
  accountID: String!
}

input PutIAMUserPolicyInput {
  """The name of the user to create"""
  userName: String!
  """The policy document in string format"""
  policyDocument: String!
  """The name of the policy document"""
  policyName: String!
  """The account where resource will be created"""
  accountID: String!
}

"""An edge in a connection"""
type PolicyVersionsEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: PolicyVersions
}

"""accessModeType defines all available access mode for graphql."""
enum accessModeType {
  """Can be mounted in read-only mode to many hosts."""
  ReadOnlyMany
  """Can be mounted in read/write mode to many hosts."""
  ReadWriteMany
  """Can be mounted in read/write mode to exactly 1 host."""
  ReadWriteOnce
}

input PodAffinityPreferredInputType {
  """Priority to give this preferred affinity rule"""
  weight: Int
  podAffinityTerm: AffinityTermInputType
}

"""An object store tenant input"""
input TenantInput {
  alias: String!
  objectStore: NamespacedNameInput
  accountID: String!
  defaultBucketBlockSize: Int!
  complianceEnabled: Boolean!
  encryptionEnabled: Boolean!
}

"""List of Application health check information"""
type AppHealthInfo {
  """Name of application to show health check information for"""
  info: [HealthInfoOutput]
}

input IAMSAMLProviderUpdateInput {
  """The SAML XML Document"""
  document: String
  """The ARN of the SAML provider"""
  arn: String
}

"""Specifies the direction of the sort operation"""
enum SortDirection {
  """Ascending sort direction"""
  asc
  """Descending sort direction"""
  desc
}

"""An edge in a connection"""
type BucketEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Bucket
}

input DeleteWebhookConfigurationType {
  """Webhook urn (must be full URN not simple name)"""
  urn: String!
  """AccountID to use for the DCM mutation"""
  accountID: String!
}

"""
Filter information for the selection of S3 objects encrypted with AWS KMS
"""
input SseKmsEncryptedObjectsInput {
  """Not implemented. Specifies if replicas are encrypted"""
  status: String
}

input SizingInputResourceInputType {
  """The k8s node allocatable cpu"""
  cpu: QuantityInput
  """The k8s node allocatable memory"""
  memory: QuantityInput
}

"""Changes the sort order of nodes returned in a connection"""
input StoragePoliciesSort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: StoragePoliciesSortable
}

"""CSR for HTTPS endpoints"""
type CertificateSigningRequestTemplate {
  """Certificate common name"""
  commonName: String
  """Certificate contact email address"""
  email: String
  """Algorithm used to generate key"""
  keyAlgorithm: String
  """Size of the key in bits"""
  keySize: Int
  """Names used to sign this certificate"""
  names: CertificateNamesTemplate
}

"""A Kubernetes user that has been authenticated to the API"""
type AuthenticatedUser {
  aad: String
  ciphertext: String
  encryptedKey: String
  """The ID of an object"""
  id: ID!
  iv: String
  protected: String
  tag: String
}

"""Fields sortable for event field"""
enum EventSortableField {
  component
  message
  reason
  namespace
  createdOn
  updatedOn
  resourceID
  type
  count
  applicationName
  symptomID
}

"""Object store replication metrics details"""
type ReplicationDetailsType {
  """A list of all object stores targeted for replication"""
  destinationObjectStores: [ReplicationInputType]
  """
  The count of objects that have failed to replicated across all destionation object stores
  """
  failedCount: Int
  """
  The size of data that failed to replicate across all destination object stores
  """
  failedDelta: Quantity
  """The size of data replicated across all destination object stores"""
  failedDeltaBase10: Quantity
  """The size of data replicated across all destination object stores"""
  failedDeltaInMiB: Quantity
  """
  The size of data pending to be replicated across all destination object stores
  """
  pending: Quantity
  """
  The count of objects that are pending to be replicated across all object stores
  """
  pendingCount: Int
  """The size of data replicated across all destination object stores"""
  pendingDeltaBase10: Quantity
  """The size of data replicated across all destination object stores"""
  pendingDeltaInMiB: Quantity
  """
  The count of objects that have replicated to all destination object stores
  """
  replicatedCount: Int
  """The size of data replicated across all destination object stores"""
  replicatedDelta: Quantity
  """The size of data replicated across all destination object stores"""
  replicatedDeltaBase10: Quantity
  """The size of data replicated across all destination object stores"""
  replicatedDeltaInMiB: Quantity
}

"""A connection to a list of items."""
type ObjectStoreTemplateConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [ObjectStoreTemplateEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Common configuration for Kubernetes workloads"""
input WorkloadConfigInputType {
  """A list of key value pairs used to tolerate specific node taints"""
  tolerations: [StringMapInputType]
  """A key value pair used to tolerate """
  affinity: AffinityInput
  """
  Kubernetes workload resource settings to request or limit resources used on a node
  """
  resources: WorkloadConfigResourceType
  """
  A list of key value pairs used to select Kubernetes nodes for a workload
  """
  nodeSelector: [StringMapInputType]
}

input ObjectLockConfigurationRule {
  """Days for the default retention period."""
  days: Int
  """
  Retention mode you want to apply to new objects placed in the specified bucket.
  """
  mode: String
  """Years for the default retention period."""
  years: Int
}

input EventRuleInput {
  """Name and namespace of the application the eventRule belongs to"""
  application: NamespacedNameInput!
  """The eventRule to be created"""
  eventRule: EventRuleInputType!
}

"""Kubernetes Persistent Volume"""
type PersistentVolume implements Node & KubernetesResource {
  accessModes: [accessModeType]
  annotation: [Annotation]
  capacity: Quantity
  claimName: String
  createdTimestamp: DateTime
  creationTimestamp: String
  """The ID of an object"""
  id: ID!
  kind: String
  message: String
  name: String
  namespace: String
  readiness: String
  reason: String
  reclaimPolicy: reclaimPolicyType
  size: Quantity
  sizeResource: String
  status: persistentVolumePhaseType
  storageClassName: String
}

"""An edge in a connection"""
type StoragePolicyEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: StoragePolicy
}

input PutIAMRolePolicyInput {
  """The name of the role to create"""
  roleName: String!
  """The policy document in string format"""
  policyDocument: String!
  """The name of the policy document"""
  policyName: String!
  """The account where resource will be created"""
  accountID: String!
}

input PutIAMGroupPolicyInput {
  """The name of the group to create"""
  groupName: String!
  """The policy document in string format"""
  policyDocument: String!
  """The name of the policy document"""
  policyName: String!
  """The account where resource will be created"""
  accountID: String!
}

input IAMSAMLProviderDeleteInput {
  """The ARN of the SAML provider"""
  arn: String
}

"""ObjectStore component configuration specification"""
input ObjectStoreComponentSpecInputType {
  """
  Number of replicas that should run for this component. This field is returned objectscale-sizer.
  """
  replicas: Int
  """Connection details for the component service."""
  networkConnection: NetworkConnectionInput
  """
  Storage capacity of the component volume. This field is returned objectscale-sizer.
  """
  volumeCapacity: String
  """
  Number of storage volumes to configure for this volume. This field only applies to the storage server component.
  """
  volumeCount: Int
  """Storage class to use for this component."""
  volumeStorageClassName: String
  """
  Indicates if the volumes provided for this component are considered highly-available without additional protection by the object-store. This field is returned objectscale-sizer.
  """
  highlyAvailableVolumes: Boolean
}

"""A selector used to match Kubernetes resources by label"""
input LabelSelectorTypeInputType {
  """List of label values to match pods"""
  matchLabels: StringMapInputType
  """List of set expressions to match labels of pods"""
  matchExpressions: [MatchExpressionInput]
}

"""An edge in a connection"""
type PersistentVolumeClaimEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: PersistentVolumeClaim
}

"""An object user secret key"""
input ObjectUserSecretKeyTypeInput {
  """An Object user name"""
  objectUserName: String!
  """A secret key"""
  objectUserSecretKey: String
  """
  The number of minutes in the future that the old secret key should expire
  """
  existingKeyExpiresInMinutes: Int
}

"""An edge in a connection"""
type EventEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Event
}

"""Network connection template details for resource"""
type NetworkConnectionTemplateType {
  """Certificate files for this connection"""
  certificate: CertificateTemplateType
  """Certificate signing request for this connection"""
  certificateSigningRequest: CertificateSigningRequestTemplate
  """Type of certificate signing procedure to use for the connection"""
  certificateType: String
  """
  Configure expiry notification to be sent. This is the number of days before the certificate expires
  """
  expiryNotificationTime: Int
  """Kubernetes service type of the connection"""
  serviceType: String
}

"""A connection to a list of items."""
type AttachedPolicyConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [AttachedPolicyEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""New configuration for ECS Flex manager log receiver"""
input LogReceiverInputType {
  """Storage capacity provisioned by the automatically created log receiver"""
  storageCapacity: QuantityInput
  """
  Indicates if the manager service should create a syslog based log receiver
  """
  autoCreate: Boolean
  """Storage class used by automatically created log receiver"""
  storageClass: String
  """Network hostname of the log receiver endpoint"""
  hostname: String
  """Workload configuration of a created log receiver"""
  workloadConfig: WorkloadConfigInputType
  """Network port of the log receiver endpoint"""
  port: Int
  """Network protocol of the log receiver endpoint"""
  protocol: NetworkProtocolInputType
  """Namespace and name of the log receiver"""
  namespacedName: NamespacedNameInput
  """Application type of the log receiver"""
  type: LogReceiverApplicationInputType
}

input InputCheckType {
  """arguments to pass to the health check container"""
  args: [String]
  """name of the specific health check to run"""
  name: String
}

"""A connection to a list of items."""
type ServiceConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [ServiceEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A connection to a list of items."""
type FedObjectStoreConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [FedObjectStoreEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Changes the sort order of nodes returned in a connection"""
input AttachedGroupUserSort {
  """Name of field on which to sort the connection"""
  field: AttachedGroupUserSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""An object store tenant instance"""
type Tenant implements Node {
  alias: String
  blockSize: String
  blockSizeInCount: String
  """Returns a list of ObjectScale buckets"""
  buckets(creationTime: FilterDateTimeArgument, defaultRetention: FilterIntegerArgument, offset: Int, before: String, after: String, first: Int, last: Int, tenantID: String, name: FilterStringArgument, encryptionEnabled: FilterBooleanArgument, retention: FilterIntegerArgument, auditDeleteExpiration: FilterIntegerArgument, sort: BucketSort): BucketConnection
  complianceEnabled: Boolean
  defaultBucketBlockSize: Int
  defaultReplicationGroup: String
  encryptionEnabled: Boolean
  """The ID of an object"""
  id: ID!
  notificationSize: String
  notificationSizeInCount: String
  tenantID: String
}

"""Fields sortable for issue field"""
enum IssueSortableField {
  component
  reason
  applicationName
  createdOn
  updatedOn
  symptomID
  type
  clearType
  resourceID
  message
  namespace
}

input BucketQuotaInput {
  """Notification  size in GB"""
  notificationSize: Int
  """Block size in counts"""
  blockCounts: Int
  """Notification size in counts"""
  notificationCounts: Int
  """Block size in GB"""
  blockSize: Int
}

input IAMSAMLProviderCreateInput {
  """The human-friendly name of the SAML provider"""
  name: String
  """The SAML XML Document"""
  document: String
  """A list of key-value tags associated with the SAML provider"""
  tags: [TagInput]
  """The account to attach the provider to."""
  account: String
}

"""A connection to a list of items."""
type FederatedObjectStoreConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [FederatedObjectStoreEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A connection to a list of items."""
type AccessKeyConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [AccessKeyEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A response to an IAM Policy Version Creation request"""
type IAMCreatePolicyVersionResponse {
  """The string version name for this policy version"""
  PolicyVersion: String
  """Whether or not the iam policy version is the default"""
  SetDefault: Boolean
  """The document of this policy version"""
  document: String
}

"""The metering information about the bucket"""
type BucketObjectDistributionType {
  """The total number of objects greater than 100Kb and less than 1Mb"""
  greater100KbLess1Mb: Int
  """The total number of objects greater than 10Kb and less than 100Kb"""
  greater10KbLess100Kb: Int
  """The total number of objects greater than 1Mb"""
  greater1Mb: Int
  """The total number of objects less than 10Kb"""
  less10Kb: Int
}

"""A connection to a list of items."""
type NodeLabelConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [NodeLabelEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Usaage Type defines the types in which a Policy can be used """
enum PolicyUsageType {
  """Policy is used as a Permission Policy with IAM Entity"""
  PermissionsPolicy
  """Policy is used as a Permission boundary with IAM Entity"""
  PermissionsBoundary
}

"""Changes the sort order of nodes returned in a connection"""
input StoragePoolSort {
  """Name of field on which to sort the connection"""
  field: StoragePoolSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""Latency value in time point"""
type latencyValue {
  """Time stamp of latency value"""
  timeStamp: String
  """Latency value in milliseconds"""
  value: Float
}

"""
Input type for creating a replication configuration or replacing an existing one
"""
input BucketReplicationInputType {
  """The name of the bucket"""
  bucket: String!
  """The account ID of the expected bucket owner"""
  expectedBucketOwner: String
  """A container for replication rules"""
  replicationConfiguration: ReplicationConfigurationType!
  """
  Not implemented. A token to allow Object Lock to be enabled for an existing bucket
  """
  token: String
}

"""Fields sortable for storage class field"""
enum StoragePoolSortableField {
  dataStoreURL
  freeSpaceInMiB
  compatibleStorageClasses
  errorMessage
  name
  poolType
  errorState
  accessibleNodes
  totalCapacityInMiB
}

"""An object lock configuration associated with a bucket."""
type ObjectLockConfiguration {
  configuration: ObjectLockRuleConfiguration
  enabled: Boolean
}

"""Fields sortable for access key field"""
enum AccessKeySortableField {
  accessKeyID
  createDate
  status
  userName
  lastUsedDate
}

input IAMSAMLProviderTagInput {
  """The ARN of the SAML provider"""
  arn: String
  """A list of key-value tags associated with the SAML provider"""
  tags: [TagInput]
}

"""Name of the target platform"""
enum PlatformType {
  """RedHat OpenShift k8s container platform"""
  OpenShift
  """All other kubernetes platforms"""
  Default
  """VMware vSAN™ Persistent Services platform"""
  VMware
}

input IAMCreatePolicyVersionInput {
  """
  The ARN related to the IAM Policy which should have the version created
  """
  ARN: String!
  """The JSON document containing all of the policy information"""
  document: String!
  """Whether or not to set the new version as the default for new affectors"""
  SetDefault: Boolean
  """The accountID in plaintext"""
  account: String!
}

"""A single rule contained within a given replication configuration"""
input ReplicationRuleInputType {
  """Information about the replication destination and its configurations"""
  destination: DestinationInputType!
  """Not implemented. Replicate existing source bucket objects"""
  existingObjectReplication: ReplicationStatusInputType
  """Prefix that identifies objects to which the rule applies"""
  filter: RuleFilterInputType
  """A unique identifier for the rule. The maximum value is 255 characters"""
  id: String!
  """Indicates which rule has precedence whenever rules conflict"""
  priority: Int!
  """
  Not implemented. A container describing additional filters for identifying the source objects to replicate
  """
  sourceSelectionCriteria: ReplicationSourceSelectionCriteriaInput
  """Specifies whether the rule is enabled"""
  status: String!
  """
  Not implemented. Specifies if replicates delete markers (required with filters)
  """
  deleteMarkerReplication: DeleteMarkerReplicationInputType
}

enum ConnectionAggregationFunction {
  sum
  count
}

"""Changes the sort order of nodes returned in a connection"""
input ObjectUserSort {
  """Name of field on which to sort the connection"""
  field: ObjectUserSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""An edge in a connection"""
type RoleEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Role
}

"""An object store tenant input"""
input UpdateTenantInput {
  objectStore: NamespacedNameInput
  accountID: String
  defaultBucketBlockSize: Int
  alias: String
}

"""Changes the sort order of nodes returned in a connection"""
input HelmChartSort {
  """Name of field on which to sort the connection"""
  field: HelmChartSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""Network connection details for resource"""
type NetworkConnection {
  """Certificate for this connection"""
  certificate: Certificate
  """Certificate signing request in for this connection in PEM format"""
  certificateSigningRequest: String
  """Status of the certificate for this connection"""
  certificateStatus: CertificateStatus
  """Certificate signing type for this connection"""
  certificateType: CertificateSigningType
  """
  Configure expiry notification to be sent this number of days before the certificate expires
  """
  expiryNotificationTime: Int
  """List of hostnames applied to this connection"""
  externalHostnames: [String]
  """List of external IP addresses applied to this connection"""
  externalIPAddresses: [String]
  """The load balancer IP address of the connection"""
  loadBalancerIP: String
  """The node port address of the connection"""
  nodePort: Int
  """Kubernetes service type of the connection"""
  serviceType: ServiceServiceType
}

"""A key value pair in which the key is a string and value is a quantity"""
type StringQuantityMap {
  """Key used to select a Kubernetes resource"""
  key: String
  """Numerical representation of the resource"""
  numerical: Float
  """Quantity of infrastructure resource"""
  quantity: Quantity
  """Unit of the numerical representation of the resource"""
  unit: String
}

"""A connection to a list of items."""
type SupportAssistConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [SupportAssistEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A connection to a list of items."""
type NamespaceConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [NamespaceEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A connection to a list of items."""
type PolicyConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [PolicyEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A connection to a list of items."""
type StorageClassConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [StorageClassEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection"""
type LicenseEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: License
}

input UpdateAccountAccessKeyInput {
  """Status (Active or Inactive) of account access key"""
  status: String!
  """A unique identifier for this account"""
  accountID: String!
  """Deprecated in favor of new accountID field"""
  AccountId: String
  """A unique identifier for this account access key"""
  accessKeyId: String!
}

"""Overall health check information"""
type HealthInfo {
  """Specific information about health checks"""
  checks: [HealthCheckData]
  """Should be blank, the component is already defined"""
  component: String @deprecated(reason: "This is no longer used by the schema")
  """Should be blank, current schema does not provide overview"""
  healthchecks: Healthchecks @deprecated(reason: "This is no longer used by the schema")
  """Name of application to show health check information for"""
  name: String
  """Namespace of application to show health check information for"""
  namespace: String
  """Should be blank, current schema does not provide overview"""
  overview: String @deprecated(reason: "This is no longer used by the schema")
}

"""Configuration for ObjectScale Manager application"""
type ManagerConfig {
  """Workload configuration for GraphQL API service"""
  apiWorkloadConfig: WorkloadConfig
  """The connection details of the manager user interface and API"""
  connection: NetworkConnection
  """Default event rules applied to any new object store created"""
  defaultEventRules: [EventRule]
  """Workload configuration for Operator orchestration service"""
  deosOperatorWorkloadConfig: WorkloadConfig
  """
  Enable application to use this certificate through names matching via wildcard
  """
  enableWildcards: Boolean
  """
  Rule to apply on an event to select the list of Notifiers where the event will be sent
  """
  eventRules: [EventRule]
  """Counts for manager health-checks"""
  healthCheckCounts(groups: [String]): Counts
  """Checks to determine health of the manager"""
  healthChecks: [HealthInfo]
  """Log receiver configuration for manager"""
  logReceiver: LogReceiverConfig
  """Namespace and name of kubernetes application resource"""
  namespacedName: NamespacedName
  """The External IP of the plugin service"""
  pluginEndpoint: String
  """Available version the user could upgrade to"""
  upgradesAvailable: [String]
  """Version of the currently installed ECS Flex Manager"""
  version: String
  """Workload configuration for Zookeeper Operator orchestration service"""
  zookeeperOperatorWorkloadConfig: WorkloadConfig
}

"""A connection to a list of items."""
type StoragePolicyConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [StoragePolicyEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection"""
type AttachedGroupUsersEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: AttachedGroupUsers
}

input EventRuleDeleteInput {
  """Name of the event rule and namespace it resides in"""
  application: NamespacedNameInput!
  """Identifier of the event rule to be deleted"""
  eventRuleIdentifier: Int!
}

type ConnectionAggregation {
  groups: [groups]
  """Total number of edges in this connection"""
  total: Int
}

"""A string used to group of filter object stores"""
type Group implements Node {
  """The ID of an object"""
  id: ID!
  name: String
}

"""An object store alert policy condition instance"""
type AlertPolicyCondition {
  """Severity type of the alert policy. Warning, Critical, etc"""
  severityType: String
  """Type of value for the threshold value of the alert policy"""
  thresholdUnits: String
  """Threshold value limit of the alert policy"""
  thresholdValue: String
}

"""An object store tenant input"""
input DeleteTenantInput {
  accountID: String
  objectStore: NamespacedNameInput
}

"""ObjectStore configuration specification"""
input ObjectStoreSpecInputType {
  """Bookkeeper component specification"""
  bookkeeperIndex: ObjectStoreComponentSpecInputType
  """Grafana component specification"""
  grafana: ObjectStoreComponentSpecInputType
  """ons component specification"""
  ons: ObjectStoreComponentSpecInputType
  """Fluxd component specification"""
  fluxd: ObjectStoreComponentSpecInputType
  """Throttler component specification"""
  throttler: ObjectStoreComponentSpecInputType
  """Control component specification"""
  control: ObjectStoreComponentSpecInputType
  """ManagementGateway component specification"""
  managementGateway: ObjectStoreComponentSpecInputType
  """ChunkManager component specification"""
  chunkManager: ObjectStoreComponentSpecInputType
  """Zookeeper component specification"""
  zookeeper: ObjectStoreComponentSpecInputType
  """StorageServer component specification"""
  storageServer: ObjectStoreComponentSpecInputType
  """Metering component specification"""
  metering: ObjectStoreComponentSpecInputType
  """pravegaController component specification"""
  pravegaController: ObjectStoreComponentSpecInputType
  """Bookkeeper component specification"""
  bookkeeperJournal: ObjectStoreComponentSpecInputType
  """Diagnostic component specification"""
  diagnostic: ObjectStoreComponentSpecInputType
  """geoService component specification"""
  geoService: ObjectStoreComponentSpecInputType
  """Blob component specification"""
  blob: ObjectStoreComponentSpecInputType
  """RecordManager component specification"""
  recordManager: ObjectStoreComponentSpecInputType
  """Bookkeeper component specification"""
  bookkeeperLedger: ObjectStoreComponentSpecInputType
  """controlPlane component specification"""
  controlPlane: ObjectStoreComponentSpecInputType
  """Profile for the object-store"""
  profile: Profile!
  """Object service component specification"""
  objectsvc: ObjectStoreComponentSpecInputType
  """segmentStore component specification"""
  segmentStore: ObjectStoreComponentSpecInputType
  """Event component specification"""
  event: ObjectStoreComponentSpecInputType
  """nds component specification"""
  nds: ObjectStoreComponentSpecInputType
  """SpaceReclaimer component specification"""
  spaceReclaimer: ObjectStoreComponentSpecInputType
  """InfluxDB component specification"""
  influxDB: ObjectStoreComponentSpecInputType
  """StorageManagement component specification"""
  storageManagement: ObjectStoreComponentSpecInputType
  """rep component specification"""
  rep: ObjectStoreComponentSpecInputType
  """ObjectStore Metering"""
  objectStoreMetering: ObjectStoreComponentSpecInputType
  """Resource component specification"""
  resource: ObjectStoreComponentSpecInputType
  """Telegraf component specification"""
  telegraf: ObjectStoreComponentSpecInputType
  """DEOSEvents component specification"""
  deosEvents: ObjectStoreComponentSpecInputType
  """Atlas component specification"""
  atlas: ObjectStoreComponentSpecInputType
  """S3 component specification"""
  s3: ObjectStoreComponentSpecInputType
  """GeoReceiver component specification"""
  geoReceiver: ObjectStoreComponentSpecInputType
  """StorageServerManager component specification"""
  storageServerManager: ObjectStoreComponentSpecInputType
}

"""An ECS object storage cluster instance"""
type ObjectUser implements Node {
  accessKey: String
  creationTime: String
  """The ID of an object"""
  id: ID!
  secretKeys: [ObjectUserSecretKey]
}

"""Configuration for object store storage topology"""
type StorageTopologyConfig {
  """The disallowed fault domains for resource scheduling"""
  excludedFaultDomains: [String]
  """
  List of node hostnames (kubernetes.io/hostname label) to be excluded from resource scheduling
  """
  excludedNodes: [String]
  """The topology spread and excluded fault domains key"""
  faultDomainKey: String
  """The list of nodes to be excluded"""
  nodeSelector: NodeSelectionInputType @deprecated(reason: "Use excludedNodes to restrict object store resource scheduling")
}

"""Information about installed settings"""
input SizingInputTypeInput {
  """List of storage pools available for this object store"""
  storagePoolList: [StoragePoolInput]
  """Storage class to be used for system data volumes"""
  systemDataStorageClass: SizingInputStorageClassInput
  """Storage class to be used for user storage server data volumes"""
  userDataStorageClass: SizingInputStorageClassInput
  """Selected performance profile"""
  selectedNodeCount: Int
  """Indicates that type of protection scheme used for user data"""
  erasureCodingScheme: ErasureCodingSchemeType
  """The K8S nodes available for object store scheduling"""
  clusterNodes: [ClusterNodesInputType]
  """Number of desired transactions per second"""
  transactions: Int = 0
  """Recommended performance profile"""
  selectedProfile: Profile
  """
  Projected years of growth compoundly at the given GrowthRate for the store
  """
  selectedYearsOfGrowth: Int
  """Storage class to be used for stream data volumes"""
  streamDataStorageClass: SizingInputStorageClassInput
  """Indicates that the object store is using HA volumes"""
  highlyAvailableVolumes: Boolean = false
  """Selected volume capacity for storage server component"""
  selectedVolumeCapacity: QuantityInput
  """Show how much capacity is needed"""
  version: String
  """Available drive technologies"""
  driveTechnology: DriveTechnologyType
  """List of nodes selected by user to be excluded from available resources"""
  excludedNodeList: [String]
  """Use case for the object store"""
  useCase: UseCaseType
  """Selected number of volumes for storage server component"""
  selectedVolumeCount: Int
  """Workloads to be handled by the ObjectStore"""
  workloads: [WorkloadInput]!
  """The data shell be encrypted"""
  encryption: Boolean = false
  """Selected node capacity"""
  selectedNodeCapacity: QuantityInput
  """Average ratio of reads over writes in the workload"""
  readWriteRatio: Int = 80
}

"""An amount of consumable node resource: storage, CPU, memory, etc."""
input QuantityInput {
  """The amount of on the quantity as a number"""
  value: Float
  """The measurement unit of the quantity: Ki, Mi, milli-cores, etc."""
  unit: String
}

"""An edge in a connection"""
type IAMSAMLProviderEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: IAMSAMLProvider
}

"""An object representing a cloudIQ instance."""
input SupportAssistCloudIQInput {
  """The frequency of the inventory report in minutes (5-300)"""
  inventoryFrequency: Int
  """The frequency of the performance report in minutes (5-300)"""
  performanceFrequency: Int
  """The frequency of the usage intelligence report in days (1-30)"""
  usageIntelligenceFrequency: Int
  """The frequency of the capacity report in minutes (5-300)"""
  capacityFrequency: Int
  """The frequency of the health report in minutes (5-300)"""
  healthFrequency: Int
}

enum Profile {
  Micro
  Small
  Medium
  Large
}

"""Status"""
type Status {
  """ESE version used by SupportAssist to connect to Dell"""
  eseVersion: String
  """The last connected date/time for SupportAssist."""
  lastConnected: String
  """The last connected date/time for SupportAssist."""
  lastConnectionAttempt: String
  """The most recent time that SupportAssist was updated."""
  lastUpdated: String
  """Current phase of this SupportAssist configuration."""
  phase: String
  """Serial Number of this SupportAssist configuration."""
  serialNumber: String
  """Current state of this SupportAssist configuration."""
  state: String
  """quick summary of the current state for this SupportAssist connection."""
  statusMessage: String
}

"""CustomerContact detail for the SupportAssist"""
type CustomerContact {
  """The order in priority of the customer contact"""
  contactOrder: Int
  """The email address of the customer contact"""
  emailAddress: String
  """The first name of the customer contact"""
  firstName: String
  """The last name of the customer contact"""
  lastName: String
  """The phone number of the customer contact"""
  phoneNumber: String
  """The preferred contact method of the customer contact"""
  prefContact: String
  """The preferred contact time of the customer contact"""
  prefContactTime: String
  """The preferred language of the customer contact"""
  prefLanguage: String
  """The time zone offset of the customer contact"""
  timeZoneOffset: String
}

"""last time the role is used."""
type LastUsed {
  """
  The date and time, in ISO 8601 date-time format, when the role was created
  """
  lastUsedDate: DateTime
  """which AWS region the role is created"""
  region: String
}

"""An edge in a connection"""
type HelmChartEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: HelmChart
}

"""An edge in a connection"""
type AlertPolicyEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: AlertPolicy
}

"""Fields sortable for license field"""
enum LicenseSortableFieldV2 {
  enterpriseSoftwareID
  instanceSoftwareID
  name
  namespace
}

"""Fields sortable for objectstore template field"""
enum ObjectStoreTemplateSortableField {
  name
}

"""Changes the sort order of nodes returned in a connection"""
input IAMGroupSort {
  """Name of field on which to sort the connection"""
  field: IAMGroupSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

type RootMutation {
  acknowledgeEvent(
    """Id of an event"""
    eventId: String!
  ): Event
  acknowledgeIssue(
    """Id of an issue"""
    issueId: String!
  ): Issue
  addUserToGroup(input: AddUserToGroupInput!): User
  applyLicense(
    """apply a license"""
    input: LicenseInput!
  ): LicenseType
  approveCertificateRequest(
    """approve certificate request"""
    input: ApproveCertificateRequestInput!
  ): Certificate
  attachIAMGroupPolicy(
    """input params to attach a group policy"""
    input: AttachIAMGroupPolicyInput!
  ): AttachedPolicy
  attachIAMRolePolicy(
    """input params to attach a role policy"""
    input: AttachIAMRolePolicyInput!
  ): AttachedPolicy
  attachIAMUserPolicy(
    """input params to attach a user policy"""
    input: AttachIAMUserPolicyInput!
  ): AttachedPolicy
  attachRoleTag(id: ID!, tags: [TagInput]!): Role
  attachUserTag(tags: [TagInput]!, id: ID!): User
  """Configure the log receiver for the ECS Flex Manager"""
  clearManagerLogReceiver: LogReceiverConfig
  clearObjectStoreLogReceiver(
    """Object store for which to clear the log receiver configuration"""
    namespacedName: NamespacedNameInput!
  ): LogReceiverConfig
  """Configure the log receiver for the ECS Flex Manager"""
  configureManagerLogReceiver(
    """Configure manager log receiver"""
    input: LogReceiverInputType
  ): LogReceiverConfig
  configureObjectStoreLogReceiver(
    """Configure object store log receiver"""
    input: LogReceiverInputType!
  ): LogReceiverConfig
  copyPermissionsFromUser(input: CopyPermissionsFromUserInput!): User
  createAccountAccessKey(
    """create an IAM account access key"""
    input: CreateAccountAccessKeyInput!
  ): AccountAccessKey
  createAlertPolicy(
    """Create an alert policy with the specified values"""
    input: AlertPolicyInput!
  ): AlertPolicyOutput
  createBucket(
    """create a bucket"""
    input: BucketCreationInput!
  ): Bucket
  createBucketS3(
    """create a bucket"""
    input: S3BucketCreationInput!
  ): Bucket
  createDefaultEventRule(
    """create an event rule"""
    input: EventRuleInputType!
  ): EventRule
  createEventRule(
    """create an event rule"""
    input: EventRuleInput!
  ): EventRule
  createExternalConnectivity(
    """Create an object store"""
    input: ExternalConnectionInput!
  ): NetworkConnection
  createFederationCA: String
  createIAMAccount(
    """create an IAM account"""
    input: IAMCreateAccountInput!
  ): Account
  createIAMGroup(
    """input params to create an iam group"""
    input: IAMCreateGroupInput!
  ): IAMGroup
  createIAMPolicy(
    """create an IAM policy"""
    input: IAMPolicyCreateInput
  ): Policy
  createIAMPolicyVersion(
    """update an existing IAM policy with a new version"""
    input: IAMCreatePolicyVersionInput
  ): IAMCreatePolicyVersionResponse
  createIAMRole(
    """input params to create an IAM role"""
    input: IAMCreateRoleInput!
  ): Role
  createIAMSAMLProvider(
    """create an IAM SAML Provider"""
    input: IAMSAMLProviderCreateInput
  ): IAMSAMLProvider
  createIAMUser(input: UserInput!): User
  createLicense(
    """deprecated: create a license"""
    input: LicenseInput!
  ): LicenseType @deprecated(reason: "Use ApplyLicense to apply a license")
  createNotifier(
    """create a notifier"""
    input: NotifierInput!
  ): NotifierType
  createObjectStore(
    """Create an object store"""
    input: ObjectStoreInput!
    """Save settings for this object store as a template"""
    saveAsTemplate: String
  ): ObjectStore
  createObjectUserSecretKey(
    """create an object user secret key"""
    input: ObjectUserSecretKeyInput!
  ): ObjectUserSecretKeyType
  createSRSGateway(
    """Send a request to create (register) an SRS gateway"""
    input: SRSGatewayInputType!
  ): SRSGateway
  createServiceProvider(
    """The input for create service provider request"""
    input: CreateServiceProviderInput!
  ): ServiceProvider
  createSupportAssist(
    """Create a SupportAssist resource instance with specified values."""
    input: SupportAssistConfigEditInput
  ): SupportAssist
  createTenant(
    """Create a tenant with the specified values."""
    input: TenantInput
  ): TenantCreate
  createUserAccessKey(accountID: String!, userName: String!): AccessKey
  createWebhookConfiguration(
    """create a webhookconfiguration for an account"""
    input: CreateWebhookConfigurationType!
  ): WebhookConfiguration
  deleteAccountAccessKey(
    """deletes an IAM account access key"""
    input: DeleteAccountAccessKeyInput!
  ): AccountAccessKey
  deleteAlertPolicy(
    """Delete an alert policy with the specified values"""
    input: DeleteAlertPolicyInput
  ): AlertPolicyOutput
  deleteBucket(id: ID!): Bucket
  deleteBucketReplication(id: ID!): Bucket
  deleteCertificate(
    """delete a certificate"""
    input: CertificateInput!
  ): String
  deleteDefaultEventRule(
    """delete an event rule"""
    input: DefaultEventRuleDeleteInput!
  ): EventRule
  deleteEventRule(
    """delete an event rule"""
    input: EventRuleDeleteInput!
  ): EventRule
  deleteIAMAccount(
    """delete an IAM account"""
    input: IAMDeleteAccountInput!
  ): Account
  deleteIAMGroup(id: ID!): IAMGroup
  deleteIAMGroupPolicy(
    """input params to delete an IAM inline group policy"""
    input: DeleteIAMGroupPolicyInput!
  ): IAMInlinePolicy
  deleteIAMPolicy(id: ID!): Policy
  deleteIAMPolicyVersion(
    """Delete an existing IAM policy version"""
    input: IAMDeletePolicyVersionInput
  ): Boolean
  deleteIAMRole(id: ID!): Role
  deleteIAMRolePolicy(
    """input params to delete an IAM inline role policy"""
    input: DeleteIAMRolePolicyInput!
  ): IAMInlinePolicy
  deleteIAMSAMLProvider(
    """delete an IAM SAML provider"""
    input: IAMSAMLProviderDeleteInput
  ): Boolean
  deleteIAMUser(id: ID!): User
  deleteIAMUserPolicy(
    """input params to delete an IAM inline user policy"""
    input: DeleteIAMUserPolicyInput!
  ): IAMInlinePolicy
  deleteLicense(
    """delete a license"""
    input: DeleteLicenseInput!
  ): LicenseType
  deleteNotifier(
    """delete a notifier"""
    input: NotifierInput!
  ): NotifierType
  deleteObjectStores(
    """Information to delete a list of object stores"""
    input: ObjectStoreBulkActionInput!
  ): [ObjectStore]
  deleteObjectUserSecretKey(
    """Delete an object user secret key"""
    input: ObjectUserSecretKeyInputDelete!
  ): String
  deleteQuota(id: ID!): BucketQuota
  deleteRolePermissionsBoundary(id: ID!): Role
  deleteSRSGateway(
    """Delete an SRS gateway"""
    input: NamespacedNameInput!
  ): String
  deleteServiceProvider: ServiceProvider
  deleteSupportAssist(
    """Delete a SupportAssist resource instance."""
    input: NamespacedNameInput!
  ): String
  deleteTenant(
    """Delete a tenant with the specified values."""
    input: DeleteTenantInput
  ): TenantCreate
  deleteTenantQuota(
    """Delete a tenant's quota parameters"""
    input: DeleteTenantQuotaInput
  ): TenantCreate
  deleteUserAccessKey(id: ID!): AccessKey
  deleteUserPermissionsBoundary(id: ID!): User
  deleteWebhookConfiguration(
    """delete a webhookconfiguration for an account"""
    input: DeleteWebhookConfigurationType!
  ): String
  detachGroupPolicy(
    """input params to create an IAM inline group policy"""
    input: DetachGroupPolicyInput!
  ): DetachGroupPolicyType
  detachRolePolicy(
    """input params to create an IAM inline role policy"""
    input: DetachRolePolicyInput!
  ): DetachRolePolicyType
  detachRoleTag(tagKeys: [String]!, id: ID!): Role
  detachUserPolicy(
    """input params to create an IAM inline user policy"""
    input: DetachUserPolicyInput!
  ): DetachUserPolicyType
  detachUserTag(id: ID!, tagKeys: [String]!): User
  dialHomeSRS(
    """Perform dial-home call for an SRS server"""
    input: NamespacedNameInput!
  ): String
  disableBucketVersioning(id: ID!): String
  disableHealthCheck(
    """Healthchecks for the application and namespace it resides in"""
    application: NamespacedNameInput!
  ): Boolean
  disableSRSGateway(
    """Disable an SRS server"""
    input: NamespacedNameInput!
  ): String
  editSupportAssist(
    """Edit a SupportAssist instance."""
    input: SupportAssistConfigEditInput
  ): SupportAssist @deprecated(reason: "Moving towards UpdateSupportAssist going forward.")
  enableBucketObjectLock(id: ID!): String
  enableBucketVersioning(id: ID!): String
  enableHealthCheck(
    """Healthchecks for the application and namespace it resides in"""
    application: NamespacedNameInput!
  ): Boolean
  enableSRSGateway(
    """Enable an SRS server"""
    input: NamespacedNameInput!
  ): String
  initiateTrust(
    """The input to initiate trust"""
    input: InitiateTrustInput!
  ): String
  objectScaleName(
    """The input for ObjectScale name request"""
    input: ObjectScaleNameInput!
  ): String
  pauseObjectStores(
    """Information to pause an object store"""
    input: ObjectStoreBulkActionInput!
  ): [ObjectStore]
  pauseReplication(
    """The object store through which to configure the CRR action"""
    objectStore: NamespacedNameInput!
    """The node id of the federated object store being paused"""
    id: ID!
    """The future time in milliseconds to expire replication pause"""
    pauseEndMills: String!
  ): FederatedObjectStore
  postFederationSigning(
    """The input for federation signing request"""
    input: FedSigningInput!
  ): String
  putBucketNotificationConfiguration(id: ID!, input: [NotificationConfigurationInput]): String
  putBucketReplication(
    id: ID!
    """fields applied to create a replication policy for a bucket"""
    input: BucketReplicationInputType!
  ): Bucket
  putIAMGroupPolicy(
    """input params to create an IAM inline group policy"""
    input: PutIAMGroupPolicyInput!
  ): IAMInlinePolicy
  putIAMRolePolicy(
    """input params to create an IAM inline role policy"""
    input: PutIAMRolePolicyInput!
  ): IAMInlinePolicy
  putIAMUserPolicy(
    """input params to create an IAM inline user policy"""
    input: PutIAMUserPolicyInput!
  ): IAMInlinePolicy
  putRolePermissionsBoundary(id: ID!, permissionsBoundary: String): Role
  putS3LegalHold(
    """fields applied to update bucket"""
    input: PutLegalHoldInput!
  ): LegalHoldConfiguration
  putS3ObjectLockConfig(
    """fields applied to update bucket"""
    input: PutObjectLockPolicyInput!
  ): ObjectLockConfiguration
  putUserPermissionsBoundary(id: ID!, permissionsBoundary: String): User
  removeUserFromGroup(input: RemoveUserFromGroupInput!): User
  resumeObjectStores(
    """Information to resume an object store"""
    input: ObjectStoreBulkActionInput!
  ): [ObjectStore]
  resumeReplication(
    """The object store through which to configure the CRR action"""
    objectStore: NamespacedNameInput!
    """The node id of the federated object store being resumed"""
    id: ID!
  ): FederatedObjectStore
  runHealthCheck(
    """Healthchecks for the application and namespace it resides in"""
    input: [HealthCheckInputType]
  ): AppHealthInfo
  setDefaultIAMPolicyVersion(
    """Set an existing IAM policy version as the default policy version"""
    input: IAMSetDefaultPolicyVersionInput
  ): Boolean
  setTenantQuota(
    """Set a tenant's quota parameters"""
    input: SetTenantQuotaInput
  ): TenantCreate
  suspendReplication(
    """The object store through which to configure the CRR action"""
    objectStore: NamespacedNameInput!
    """The node id of the federated object store being suspended"""
    id: ID!
  ): FederatedObjectStore
  tagIAMSAMLProvider(
    """tag an IAM SAML provider"""
    input: IAMSAMLProviderTagInput
  ): IAMSAMLProvider
  testConnectionSupportAssist(
    """Test SupportAssist connectivity to Dell."""
    input: NamespacedNameInput!
  ): SupportAssist
  throttleReplication(
    """The object store through which to configure the CRR action"""
    objectStore: NamespacedNameInput!
    """The node id of the federated object store being throttled"""
    id: ID!
    """
    The replication bandwidth cap in MB/s to set on destination object store
    """
    throttledMbPerSecond: Int!
  ): FederatedObjectStore
  toggleIAMAccountDisabled(
    """disable an IAM account"""
    input: ToggleIAMAccountDisabledInput!
  ): Account
  toggleIAMAccountTSO(
    """disable an IAM account"""
    input: ToggleIAMAccountTSOInput!
  ): Account
  unacknowledgeEvent(
    """Id of an event"""
    eventId: String!
  ): Event
  unacknowledgeIssue(
    """Id of an issue"""
    issueId: String!
  ): Issue
  untagIAMSAMLProvider(
    """untag an IAM SAML provider"""
    input: IAMSAMLProviderUntagInput
  ): IAMSAMLProvider
  unthrottleReplication(
    """The object store through which to configure the CRR action"""
    objectStore: NamespacedNameInput!
    """The node id of the federated object store being unthrottled"""
    id: ID!
  ): FederatedObjectStore
  updateAccountAccessKey(
    """deletes an IAM account access key"""
    input: UpdateAccountAccessKeyInput!
  ): AccountAccessKey
  updateAlertPolicy(
    """Update an alert policy with the specified values"""
    input: AlertPolicyInput!
  ): AlertPolicyOutput
  updateAssumeRolePolicy(
    """update an existing IAM role with a new assumed policy"""
    input: IAMUpdateRolePolicyInput
  ): Role
  updateBucket(
    id: ID!
    """fields applied to update bucket"""
    input: BucketUpdateInput!
  ): Bucket
  updateBucketPolicy(
    id: ID!
    """fields applied to updated bucket"""
    input: BucketPolicyInput!
  ): Bucket
  updateDECKSConfig(
    """update DECKS """
    input: DECKSConfigInput!
  ): DECKSConfig
  updateDefaultEventRule(
    """update an event rule"""
    input: DefaultEventRuleUpdateInput!
  ): EventRule
  updateEventRule(
    """update an event rule"""
    input: EventRuleUpdateInput!
  ): EventRule
  updateIAMAccount(
    """update an IAM account"""
    input: IAMUpdateAccountInput!
  ): Account
  updateIAMGroup(
    """Input params to update an iam group"""
    input: IAMUpdateGroupInput!
  ): IAMGroup
  updateIAMRole(
    """input params to update an IAM role"""
    input: IAMUpdateRoleInput!
  ): Role
  updateIAMSAMLProvider(
    """update an IAM SAML provider"""
    input: IAMSAMLProviderUpdateInput
  ): IAMSAMLProvider
  updateIAMUser(input: UpdateUserInput!): User
  updateManagerConfig(
    """update manager config"""
    input: ManagerConfigInput!
  ): ManagerConfig
  updateNotifier(
    """update a notifier"""
    input: NotifierInput!
  ): NotifierType
  updateObjectStore(
    """Update an object store"""
    input: ObjectStoreInput!
  ): ObjectStore
  updateQuota(
    id: ID!
    """fields applied to update quota"""
    input: BucketQuotaInput!
  ): BucketQuota
  updateSupportAssist(
    """Update a SupportAssist instance."""
    input: SupportAssistConfigEditInput
  ): SupportAssist
  updateTenant(
    """Update a tenant with the specified values."""
    input: UpdateTenantInput
  ): TenantCreate
  updateUserAccessKey(id: ID!, status: AccessKeyStatusType!): AccessKey
  upgradeHelmRelease(
    """Name of the Helm release to upgrade"""
    name: String!
    """Kubernetes namespace in which the release is installed"""
    namespace: String!
    """Helm chart version to which the release should be upgraded"""
    version: String!
  ): HelmRelease
  upgradeManager(
    """update manager config"""
    input: ManagerUpgradeInput!
  ): ManagerConfig
  upgradeObjectStores(
    """Upgrade object stores"""
    input: ObjectStoreUpgradeInput!
  ): [ObjectStore]
  uploadCertificate(
    """upload a certificate"""
    input: CertificateInput!
  ): Certificate
  uploadSignedPayload(
    """upload signed payload to secondary ObjectScale instance"""
    input: UploadSignedPayloadInput!
  ): String
}

"""A single key value pair."""
input TagInput {
  """(Required) custom key"""
  key: String!
  """(Required) custom value"""
  value: String!
}

"""Changes the sort order of nodes returned in a connection"""
input RemoteInstanceSort {
  """Name of field on which to sort the connection"""
  field: RemoteInstanceSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""the detached group policy to a resource"""
type DetachGroupPolicyType {
  """The name of the user"""
  groupName: String
  """Amazon Resource Name of the attached policy"""
  policyArn: String
}

input ObjectStoreInput {
  """Name of the object store and namespace it resides in"""
  namespacedName: NamespacedNameInput
  """The object store to be created"""
  objectStore: ObjectStoreInputType
}

input IAMUpdateAccountInput {
  """Confirmed root password used for this account"""
  accountRootConfirmPassword: String
  """A unique identifier for this account"""
  accountID: String!
  """A simple name used for this account"""
  alias: String
  """A longer text description of this account"""
  description: String
  """A root user for this account"""
  accountRootUser: String
  """Root password used for this account"""
  accountRootPassword: String
}

"""An object store alert policy instance"""
type AlertPolicyOutput {
  condition: AlertPolicyCondition
  """Description of creator of the alert policy"""
  createdBy: String
  """Number of data points breaching the threshold before raising an alert"""
  datapointsToAlert: Int
  """AWS Evaluation Period"""
  datapointsToConsider: Int
  """ObjectStore ID written in namespace/ObjectStore format"""
  id: String
  """Determines whether or not the alert policy is active"""
  isEnabled: String
  """Determines if policy metric is for per-VDC or per-Host"""
  isPerInstanceMetric: String
  """Metric name of the alert policy"""
  metricName: String
  """Metric type of the alert policy"""
  metricType: String
  """Operator type of the alert policy. Greater_than, Lesser_than, etc"""
  operator: String
  """How often data points are created for the alert policy"""
  period: Int
  """Type of period such as seconds, minutes, days, etc"""
  periodUnits: String
  """Policy name of the alert policy"""
  policyName: String
  """
  Statistic type of the alert policy. Avg, min, max, count, sum, p90, etc
  """
  statistic: String
}

input BucketPolicyInput {
  """The bucket policy to be applied"""
  policy: String
}

"""Additional filters for identifying the source objects for replication"""
input ReplicationSourceSelectionCriteriaInput {
  """
  Not implemented. Filter information for the selection of objects encrypted with AWS KMS
  """
  sseKmsEncryptedObjects: SseKmsEncryptedObjectsInput
  """
  Not implemented. A filter that you for specifying selections for modifications on replicas
  """
  replicaModifications: SourceSelectionCriteriaInput
}

"""A connection to a list of items."""
type HelmChartConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [HelmChartEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A connection to a list of items."""
type ObjectUserConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [ObjectUserEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

enum DriveTechnologyType {
  SSD
  HDD
}

input ManagerConfigInputType {
  """
  Enable application to use this certificate through names matching via wildcard
  """
  enableWildcards: Boolean
  """Workload configuration for GraphQL API service"""
  apiWorkloadConfig: WorkloadConfigInputType
  """Workload configuration for Operator orchestration service"""
  deosOperatorWorkloadConfig: WorkloadConfigInputType
  """Workload configuration for Zookeeper Operator orchestration service"""
  zookeeperOperatorWorkloadConfig: WorkloadConfigInputType
  """Version of the currently installed ECS Flex Manager"""
  version: String
  """Connection details for the manager service"""
  connection: NetworkConnectionInput
}

enum AccessKeyStatusType {
  Active
  Inactive
}

type ServicePort {
  name: String
  nodePort: Int
  port: Int
  protocol: String
  targetPort: String
}

"""A connection to a list of items."""
type TenantConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [TenantEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An ObjectScale object store"""
input ObjectStoreInputType {
  """Storage class to use for control metadata"""
  systemDataStorageClass: StorageClassInput
  """Connection details for the s3 service"""
  s3Connection: NetworkConnectionInput
  """
  Storage class for monitoring subchart (defaults to metadataStorageClass)
  """
  monitoringStorageClass: StorageClassInput
  """Performance profile of the object store"""
  profile: String
  """
  Indicates if the volumes provisioned for object store will survive a node outage
  """
  highlyAvailableVolumes: Boolean
  """Connection details for the geo service"""
  replicationConnection: NetworkConnectionInput
  """
  ObjectStore configuration specification to apply to the new created instance
  """
  spec: ObjectStoreSpecInputType
  platform: PlatformType
  """Version of the object store"""
  version: String!
  """Storage class to use for user data and metadata"""
  userDataStorageClass: StorageClassInput
  """Storage topology configuration for the object store"""
  storageTopology: StorageTopologyInput
  """
  User defined group to be assigned to the object store for logical organization
  """
  group: String
  """Output block from ObjectScale sizing"""
  sizingOutput: ObjectStoreOutputType
  """Connection details for the management service"""
  managementConnection: NetworkConnectionInput
  """Input parameters passed to ObjectScale for sizing of object store"""
  sizingInput: SizingInputTypeInput
  """The Kubernetes storageclass used for stream data"""
  streamDataStorageClass: StorageClassInput
}

"""Specifies replication time control related information"""
input ReplicationTimeInputType {
  """
  Not implemented. The time replication on all objects and operations should be finished
  """
  time: ReplicationTimeValueInputType!
  """Not implemented. Specifies whether replication time is enabled"""
  status: String!
}

"""A connection to a list of items."""
type ObjectStoreConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [ObjectStoreEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Resource Type for cluster node"""
type ResourceType {
  """CPU utilization of this cluster node"""
  cpu: Quantity
  """Memory utilization of this cluster node"""
  memory: Quantity
  """Pods utilization of this cluster node"""
  pods: Quantity
}

"""Fields sortable for stateful set field"""
enum StatefulSetSortableField {
  replicas
  name
  namespace
  creationTimestamp
  readiness
  size
}

"""The IAM Group structure"""
type IAMGroup implements Node {
  """The Amazon Resource Name (ARN) specifying the group"""
  arn: String
  """Return a list of Users"""
  attachedGroupUsers(sort: AttachedGroupUserSort, after: String, first: Int, arn: FilterStringArgument, createDate: FilterDateTimeArgument, userName: FilterStringArgument, offset: Int, before: String, last: Int, path: FilterStringArgument, permissionsBoundary: FilterStringArgument): AttachedGroupUsersConnection
  """Return a list of Policies attached to a resource"""
  attachedPolicies(policyName: FilterStringArgument, offset: Int, sort: AttachedPolicySort, before: String, after: String, first: Int, last: Int, policyArn: FilterStringArgument): AttachedPolicyConnection
  """
  The date and time, in ISO 8601 date-time format, when the group was created
  """
  createDate: DateTime
  """The stable and unique string identifying the group"""
  groupID: String
  """The friendly name that identifies the group"""
  groupName: String
  """The ID of an object"""
  id: ID!
  """Return a list of inline policies"""
  inlinePolicies(policyName: FilterStringArgument, policyDocument: FilterStringArgument, offset: Int, sort: InlinePolicySort, before: String, after: String, first: Int, last: Int): IAMInlinePolicyConnection
  """The path to the group"""
  path: String
}

"""A notifier resource"""
type NotifierType {
  namespacedName: NamespacedName
  notifierConfig: NotifierConfigType
}

"""Input type for a replication configuration"""
input ReplicationConfigurationType {
  """ARN of the AWS IAM role used for replicating objects"""
  role: String!
  """
  Indicates that the storage class provisions volumes local to a single host
  """
  rules: [ReplicationRuleInputType]!
}

"""Service or job to check on the status of a Kubernetes applicaion"""
type Healthcheck {
  """Optional arguments to pass to the container image"""
  args: [String]
  """Name of the container that will be run"""
  container: String
  """Whether this health check is enabled to run on its schedule"""
  disabled: Boolean
  """Name of the health check"""
  name: String
  """Schedule for the health check to run"""
  schedule: String
  """Schedule for the health check to run"""
  scheduledTime: DateTime
  """Time limit for container to run"""
  timelimit: String
}

"""KAHM application health issues"""
type Issue implements Node {
  """Indicates if the issue has been manually acknowledged by the user."""
  acknowledged: Boolean
  """The name of the application on which the issue have occurred"""
  applicationName: String
  """Time after that the issue will be auto-cleared"""
  autoClearTimeOut: Int
  """
  The clearType indicates if the issue needs manual acknowledgement or auto-clearable
  """
  clearType: IssueClearTypes
  """The component that generates alerts for the issue"""
  component: String
  """The time and date when the issue was created"""
  createdOn: DateTime
  """Return a list events"""
  events(namespace: FilterStringArgument, acknowledged: FilterBooleanArgument, component: FilterStringArgument, reason: FilterStringArgument, symptomID: FilterStringArgument, message: FilterStringArgument, applicationName: FilterStringArgument, resourceID: FilterStringArgument, offset: Int, after: String, type: FilterStringArgument, createdOn: FilterDateTimeArgument, updatedOn: FilterDateTimeArgument, count: Int, sort: EventSort, before: String, first: Int, last: Int): EventConnection
  """The ID of an object"""
  id: ID!
  """The detailed description of the issue"""
  message: String
  """The application is deployed at this namespace"""
  namespace: String
  """The short reason for the issue"""
  reason: String
  """
  Provides a list of possible solutions that the user may perform to resolve the issue
  """
  remedies: [String]
  """The kubernetes resource on which the issue is active"""
  resourceID: String
  """The id of the issue"""
  symptomID: String
  """The type indicates the severity of the issue"""
  type: IssueTypes
  """The time and date when the issue was last updated"""
  updatedOn: DateTime
}

"""A Kubernetes storageclass used to logically group resources"""
type StorageClass implements Node {
  driveTechnology: DriveTechnologyType
  hostLocal: Boolean!
  """The ID of an object"""
  id: ID!
  name: String
  storagePoolTypes: [String]
}

"""The IAM Policy Version structure"""
type PolicyVersions implements Node {
  """The string version name for this policy version"""
  PolicyVersion: String
  """Whether or not the iam policy version is the default"""
  SetDefault: Boolean
  """Date on which this policy was created"""
  createDate: DateTime
  """The document of this policy version"""
  document: String
  """The ID of an object"""
  id: ID!
}

enum CertificateSigningType {
  ExternallySigned
  KubernetesSigned
  InternallySigned
  SelfSigned
}

"""TLS Certificate for HTTPS endpoints"""
type Certificate {
  """Certificate common name"""
  commonName: String
  """Certificate contact email address"""
  email: String
  """Hosts signed by this certificate"""
  hosts: CertificateHosts
  """cert issuer info"""
  issuer: Issuer
  """Algorithm used to generate key"""
  keyAlgorithm: String
  """Size of the key in bits"""
  keySize: Int
  """Names used to sign this certificate"""
  names: CertificateNames
  """Starting date that the certificate was issued"""
  validFrom: String
  """Date on which the certificate expires"""
  validTo: String
}

"""the attached policy to a resource"""
type AttachedPolicy implements Node {
  """The ID of an object"""
  id: ID!
  """Amazon Resource Name of the attached policy"""
  policyArn: String
  """The friendly name (not ARN) identifying the attached policy"""
  policyName: String
}

type WebhookConfiguration {
  urn: String
  webhookConfig: Webhook
}

"""An edge in a connection"""
type ObjectUserEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: ObjectUser
}

"""Fields sortable for persistentVolumeClaim field"""
enum PersistentVolumeClaimSortableField {
  capacity
  storageClassName
  volumeMode
  name
  namespace
  creationTimestamp
  readiness
  size
}

type Role implements Node {
  """The name of the role"""
  arn: String
  """
  The trust relationship policy document that grants an entity permission to assume the role
  """
  assumeRolePolicyDocument: String
  """Return a list of Policies attached to a resource"""
  attachedPolicies(first: Int, last: Int, policyArn: FilterStringArgument, policyName: FilterStringArgument, offset: Int, sort: AttachedPolicySort, before: String, after: String): AttachedPolicyConnection
  """
  The date and time, in ISO 8601 date-time format, when the group was created
  """
  createDate: DateTime
  """The description of the role"""
  description: String
  """The ID of an object"""
  id: ID!
  """Return a list of inline policies"""
  inlinePolicies(before: String, after: String, first: Int, last: Int, policyName: FilterStringArgument, policyDocument: FilterStringArgument, offset: Int, sort: InlinePolicySort): IAMInlinePolicyConnection
  """
  The maximum duration of the session the role will have valid credentials
  """
  maxSessionDuration: Int
  """path to the role"""
  path: String
  """
  ARN of the policy that is used to set the permissions boundary for the role
  """
  permissionsBoundary: PermissionBoundary
  """role id of the role"""
  roleID: String
  """role last used"""
  roleLastUsed: LastUsed
  """The name of the role"""
  roleName: String
  """list of key values pairs"""
  tags: [Tag]
}

"""Overall health check information"""
type HealthInfoOutput {
  """Specific information about health checks"""
  checks: [Check]
  """Name of application to show health check information for"""
  name: String
  """Namespace of application to show health check information for"""
  namespace: String
  """Current state of the check(s) for this application"""
  status: String
}

"""Fields sortable for alert policy field"""
enum AlertPolicySortableField {
  policyName
}

"""Changes the sort order of nodes returned in a connection"""
input ClusterNodeSort {
  """Name of field on which to sort the connection"""
  field: ClusterNodeSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

input DetachGroupPolicyInput {
  """The Resource Name of the attached policy for group"""
  policyArn: String!
  """The account ID of the group"""
  accountID: String!
  """The name of the group"""
  groupName: String!
}

"""An ECS ObjectScaleInfo type"""
type ObjectScaleInfo {
  csrSignerSerialNo: String
  objectScaleId: String
  objectScaleName: String
  objectScaleNamespace: String
  services: [ObjectScaleService]
  type: String
}

"""Fields sortable for cluster node field"""
enum ClusterNodeSortableField {
  totalStorage
  role
  internalStorageTotal
  internalStorageFree
  externalStorageTotal
  externalStorageFree
  allocatableMemory
  allocatableCPU
  allocatablePod
  name
  available
  availableStorage
}

"""Object store possible state"""
type StateType {
  """Description of state"""
  description: String
  """Name of state"""
  name: String
}

"""Indicates the current status of an SRS gateway"""
enum SRSGatewayState {
  Registered
  Configuring
  Disabled
}

"""An object store delete alert policy input instance"""
input DeleteAlertPolicyInput {
  """ObjectStore ID written in namespace/ObjectStore format"""
  id: String
  """Policy name of the alert policy"""
  policyName: String
}

"""IAM user used to manage object stores"""
input UserInput {
  """A list of tags that are associated with the specified user"""
  tags: [TagInput]
  """The friendly name identifying the user"""
  userName: String
  """The account ID of the user"""
  accountID: String
  """The path to the user"""
  path: String
  """
  The ARN of the policy used to set the permissions boundary for the user
  """
  permissionsBoundary: String
}

"""Specifies if replicates delete markers"""
input DeleteMarkerReplicationInputType {
  """Not implemented. Indicates whether to replicate delete markers"""
  deleteMarkerReplication: String
}

"""A connection to a list of items."""
type AlertPolicyConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [AlertPolicyEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Fields sortable for deployment field"""
enum DeploymentSortableField {
  readiness
  size
  namespace
  creationTimestamp
  readyReplicas
  availableReplicas
  unavailableReplicas
  name
  replicas
}

"""An edge in a connection"""
type IssueEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Issue
}

"""Configuration for KAHM application"""
type KAHMConfigTypeName {
  """Event rules applied to events emitted from KAHM application"""
  eventRules: [EventRule]
  """Namespace and name of kubernetes application resource"""
  namespacedName: NamespacedName
  """Authentication realm to use with KAHM REST API"""
  realm: String
  """Password to use with KAHM REST API"""
  restPassword: String
  """Username to use with KAHM REST API"""
  restUsername: String
  """KAHM version"""
  version: String
  """Workload configuration for KAHM pod"""
  workloadConfig: WorkloadConfig
}

"""
A single customer contact, with various details pertaining to the person.
"""
input CustomerContactInput {
  """The preferred method of contact"""
  prefContact: String
  """The preferred time to be contacted"""
  prefContactTime: String
  """(Required) The email address of the customer contact"""
  emailAddress: String!
  """The preferred language in which email messages should be sent."""
  prefLanguage: String
  """
  (Required) Identification of the primary and secondary contact.  1 is primary, 2 is secondary
  """
  contactOrder: Int!
  """(Required) The last name of the customer contact"""
  lastName: String!
  """(Required) The first name of the customer contact"""
  firstName: String!
  """(Required) The phone number of the customer contact"""
  phoneNumber: String!
  """The time zone offset of the customer contact"""
  timeZoneOffset: String
}

"""gateway to connect to SupportAssist """
type Gateway {
  """
  The IP, or DNS-resolvable name of the gateway that the SupportAssist resource will use, not including the port.
  """
  hostname: String
  """Port used for the hostname attached to the gateway"""
  port: Int
  """
  Priority of the gateway, ranges in value from 1-1000, with 1 being the highest priority
  """
  priority: Int
}

input DefaultEventRuleDeleteInput {
  """Identifier of the event rule to be deleted"""
  eventRuleIdentifier: Int!
}

"""Changes the sort order of nodes returned in a connection"""
input FederatedObjectStoreSort {
  """Name of field on which to sort the connection"""
  field: FederatedObjectStoreSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

type NamespacedName {
  """Name of the resource"""
  name: String
  """Namespace of the object"""
  namespace: String
}

"""Changes the sort order of nodes returned in a connection"""
input AccessKeySort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: AccessKeySortableField
}

type AccessKey implements Node {
  """The access key id"""
  accessKeyID: String!
  """The date the access key was created"""
  createDate: DateTime!
  """The ID of an object"""
  id: ID!
  """The date the access key was last used"""
  lastUsedDate: DateTime
  """The secret access key"""
  secretKey: String
  """The status of the access key"""
  status: String!
  """The iam user of the access key"""
  userName: String!
}

"""An object store alert policy instance"""
input AlertPolicyInput {
  """Number of data points breaching the threshold before raising an alert"""
  datapointsToAlert: Int
  """Determines whether or not the alert policy is active"""
  isEnabled: String
  """How often data points are created for the alert policy"""
  period: Int
  """Metric type of the alert policy"""
  metricType: String
  """Determines if policy metric is for per-VDC or per-Host"""
  isPerInstanceMetric: String
  """ObjectStore ID written in namespace/ObjectStore format"""
  id: String
  """Type of period such as seconds, minutes, days, etc"""
  periodUnits: String
  """Description of creator of the alert policy"""
  createdBy: String
  condition: AlertPolicyConditionInput
  """
  Statistic type of the alert policy. Avg, min, max, count, sum, p90, etc
  """
  statistic: String
  """Policy name of the alert policy"""
  policyName: String
  """Metric name of the alert policy"""
  metricName: String
  """Operator type of the alert policy. Greater_than, Lesser_than, etc"""
  operator: String
  """AWS Evaluation Period"""
  datapointsToConsider: Int
}

"""A connection to a list of items."""
type RoleConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [RoleEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A kubernetes event rule"""
type EventRule {
  description: String
  matchOn: [MatchOn]
  notifiers: [String]
}

"""A selector used to match Kubernetes resources by label"""
type LabelSelector {
  """List of set expressions to match labels of pods"""
  matchExpressions: [MatchExpression]
  """List of label values to match pods"""
  matchLabels: [StringMap]
}

"""Fields sortable for federated objectstore field"""
enum FederatedObjectStoreSortableField {
  objectScaleID
  objectStoreID
  replicationStatus
}

input SupportAssistConfigInput {
  """The Personal Identification Number used in registration."""
  pin: String
  """The site at which the SupportAssist is operating."""
  siteID: String
  """Deprecated: use testConnectivityID"""
  testDialHome: Boolean
  """A list of contacts for this instance of SupportAssist."""
  customerContacts: [CustomerContactInput]
  """Enable using gateways."""
  useGateways: Boolean
  """A list of gateways that the SupportAssist instance may use."""
  gateways: [SupportAssistGatewayInput]
  """Perform a test connectivity, send in random int from 100000-999999"""
  testConnectivityID: Int
  """Dell EMC CloudIQ advanced telemetry management."""
  cloudIQ: SupportAssistCloudIQInput
  """The version of the product configuring the SupportAssist resource."""
  productVersion: String
  """Whether or not remote access is allowed."""
  remoteAccessEnabled: Boolean
  """Whether or not the SupportAssist instance is enabled."""
  enabled: Boolean
  """When true do not automatically open service requests"""
  eventMuted: Boolean
  """The name and namespace of the location for the SupportAssist resource."""
  namespacedName: NamespacedNameInput
  """The expected operating mode of the system."""
  systemMode: String
  """The access key corresponding to the PIN used in registration."""
  accessKey: String
}

input DECKSConfigInput {
  """Name of Manager and namespace it resides in"""
  manager: NamespacedNameInput
  """The config of Manager"""
  decksConfig: DECKSConfigInputType
}

"""Checks for an application"""
type Check {
  """Name of the application check"""
  name: String
}

"""Filter connection based comparison with string or string list argument"""
input FilterDateTimeArgument {
  value: DateTime
  listValue: [DateTime]
  range: [DateTime]
  field: String
  operator: Operator
}

"""Changes the sort order of nodes returned in a connection"""
input HelmReleaseSort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: HelmReleaseSortableField
}

"""A connection to a list of items."""
type HelmReleaseConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [HelmReleaseEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""The descriptors for the Object Lock."""
type ObjectLockRule {
  days: Int
  mode: String
  years: Int
}

input NotificationConfigurationInput {
  """
  The Amazon Resource Name (ARN) of the Amazon SNS topicto which Amazon S3 publishes a message when it detects events of the specified type.
  """
  topicARN: String
  """The bucket events to watch for"""
  event: [String]
  """Filter rules for the events chosen"""
  filter: [FilterRule]
  """
  An optional unique identifier for configurations in a notification configuration.
  """
  id: String
}

"""An ECS object storage cluster remote instance"""
type RemoteInstance {
  connectivityStatus: String
  objectScaleEndpoint: String
  objectScaleId: String
  objectScaleName: String
  objectScaleNamespace: String
  trustStatus: String
  type: String
}

"""Changes the sort order of nodes returned in a connection"""
input SRSGatewaySort {
  """Name of field on which to sort the connection"""
  field: SRSGatewaySortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""SRS Test Gateway Input Type"""
input SRSTestGatewayInputType {
  """SRS Gateway username"""
  username: String
  """SRS Gateway user password"""
  password: String
  """SRS Gateway host"""
  host: String
  """SRS Gateway port"""
  port: Int
}

"""Replication metrics information and events"""
input MetricsInput {
  """
  Not implemented. The time threshold for emitting the s3:Replication:OperationMissedThreshold
  """
  eventThreshold: ReplicationTimeValueInputType
  """Not implemented. Specifies if replication metrics are enabled"""
  status: String!
}

"""Fields sortable for notifier field"""
enum NotifierSortableField {
  port
  GRPCConnTimeout
  GRPCRetries
  TotalEventsDelivered
  name
  namespace
  hostname
}

"""Persistent volume claims of an ecs cluster"""
type PersistentVolumeClaim implements Node & KubernetesResource {
  accessModes: [String]
  capacity: Quantity
  capacityInMB: Int
  creationTimestamp: String
  dataSource: LocalObjectReference
  """The ID of an object"""
  id: ID!
  kind: String
  name: String
  namespace: String
  readiness: String
  selector: LabelSelector
  size: Quantity
  sizeResource: String
  storageClassName: String
  volumeMode: String
  volumeName: String
}

enum IssueTypes {
  Warning
  Error
  Critical
  Normal
}

input ToggleIAMAccountDisabledInput {
  """An unique identifier for this account"""
  accountID: String!
  """A flag to indicate if the account should be disabled"""
  accountDisabled: Boolean!
}

"""An edge in a connection"""
type TenantEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Tenant
}

"""Changes the sort order of nodes returned in a connection"""
input PodSort {
  """Name of field on which to sort the connection"""
  field: PodSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""A kubernetes deployment"""
type Deployment implements Node & KubernetesResource {
  availableReplicas: Int
  creationTimestamp: String
  """The ID of an object"""
  id: ID!
  kind: String
  name: String
  namespace: String
  readiness: String
  readyReplicas: Int
  replicas: Int
  selector: LabelSelector
  size: Quantity
  sizeResource: String
  unavailableReplicas: Int
  updatedReplicas: Int
}

"""A connection to a list of items."""
type SRSGatewayConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [SRSGatewayEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection"""
type IAMInlinePolicyEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: IAMInlinePolicy
}

"""An edge in a connection"""
type AccountAccessKeyEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: AccountAccessKey
}

input IAMDeleteAccountInput {
  """An unique identifier for this account"""
  accountID: String!
}

"""The metering information about the bucket"""
type BucketMeteringType {
  """The compression ratio realized for this bucket"""
  compressionRatio: String
  """The total number of objects in this bucket"""
  objectCount: Int
  """The total number of deleted objects from this bucket"""
  objectDeletedCount: Int
  """The amount of capacity occupied by deleted objects in binary SI"""
  objectDeletedSize: Quantity
  """The amount of capacity occupied by deleted objects in decimal SI"""
  objectDeletedSizeBase10: Quantity
  """The amount of capacity occupied by deleted objects in MiB"""
  objectDeletedSizeInMiB: Int
  """The total number of objects distributed into 4 groups by size"""
  objectDistribution: BucketObjectDistributionType
  """The average egress latency for past 24 hours in milliseconds"""
  objectReadLatency: Int
  """The total size of read objects in binary SI over the last 24 hours"""
  objectReadSize: Quantity
  """The total size of read objects in decimal SI over the last 24 hours"""
  objectReadSizeBase10: Quantity
  """The total size of read objects in MiB over the last 24 hours"""
  objectReadSizeInMiB: Int
  """The amount of capacity consumed by end user applications in binary SI"""
  objectSize: Quantity
  """The amount of capacity consumed by end user applications in decimal SI"""
  objectSizeBase10: Quantity
  """The amount of capacity consumed by end user applications in MiB"""
  objectSizeInMiB: Int
  """The average ingress latency for past 24 hours in milliseconds"""
  objectWriteLatency: Int
  """The total size of written objects in binary SI over the last 24 hours"""
  objectWriteSize: Quantity
  """The total size of written objects in decimal SI over the last 24 hours"""
  objectWriteSizeBase10: Quantity
  """The total size of written objects in MiB over the last 24 hours"""
  objectWriteSizeInMiB: Int
  """The number of objects that have replicated to this bucket"""
  replicationObjectCount: Int
  """The amount of application data replicated to this bucket in binary SI"""
  replicationObjectSize: Quantity
  """The amount of application data replicated to this bucket in decimal SI"""
  replicationObjectSizeBase10: Quantity
  """The amount of application data replicated to this bucket in MiB"""
  replicationObjectSizeInMiB: Int
  """The total size of read objects in MiB over the last 24 hours"""
  tps: Int
}

input GetLegalHoldInput {
  """The version ID of the object that you want to place a Legal Hold on."""
  versionID: String
  """The object key that you want to place a Legal Hold on."""
  key: String
  """Acknowledgement field for paid requests."""
  requestPayer: String!
}

"""
A VMware storage policy, which controls provisioning of VMware virtual disks
"""
type StoragePolicy implements Node {
  """The ID of an object"""
  id: ID!
  """Unique name of the VMware storage policy"""
  name: String
  """Kubernetes namespace of the VMware storage policy"""
  namespace: String
  """
  Current status of the reconciliation between storage classes and storage policies
  """
  reconcileStatus: String
  """Unique identifier for the VMware vSAN storage policy"""
  storagePolicyID: String
  """Customer readable VMware storage policy name"""
  storagePolicyName: String
  """A set of rules for how the storage policy should provision volumes"""
  storagePolicyRules: [StringMap]
}

"""The attached Entity to the Policy"""
type AttachedPolicyEntity implements Node {
  """Amazon Resource ID of attached user"""
  entityID: String
  """Amazon Resource Name of attached user"""
  entityName: String
  """
  Type of the Entity associated with the Policy.  Possible values are 'User', 'Role' and 'Group'
  """
  entityType: String
  """The ID of an object"""
  id: ID!
  """Entity Usage Field accepts PermissionsPolicy and PermissionsBoundary"""
  usageType: String
}

"""A (partial) License resource"""
type LicenseType {
  activationDate: String
  eswid: String
  name: String
  subscriptionType: String
}

"""An object user secret key"""
input ObjectUserDeleteSecretKeyTypeInput {
  """An Object user name"""
  objectUserName: String!
  """A secret key"""
  objectUserSecretKey: String!
}

"""Names used to sign this certificate"""
type CertificateNames {
  """Country of origin for certificate signer"""
  country: String
  """Locality of origin (city, town, county, etc.) for certificate signer"""
  locality: String
  """Organization signing this certificate"""
  organization: String
  """Organization unit (department) signing this certificate"""
  organizationalUnit: String
  """State or province of origin for certificate signer"""
  state: String
}

"""An expressions used to match a pod label"""
type MatchExpression {
  """Label key to match against"""
  key: String
  """Operator to use in value comparisons"""
  operator: String
  """List of label values to compare against"""
  values: [String]
}

"""Replication throughput for an object store"""
type ReplicationInputType {
  """The object store being replicated to"""
  name: String
  """The CRR RTO value in a destination object store"""
  rto: Quantity
  """
  The realized bandwidth of replication data to a destination object store
  """
  throughput: Quantity
}

"""A connection to a list of items."""
type LicenseV2Connection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [LicenseV2Edge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

input NamespaceAccessListDetailsInput {
  """The name of the namespace a user has access"""
  userName: String!
  namespaceAccessList: [NamespaceAccessListInput]
}

"""Fields sortable for account field"""
enum IAMGroupSortableField {
  path
  groupID
  groupName
  arn
  createDate
}

"""Fields sortable for user field"""
enum AttachedGroupUserSortableField {
  userID
  arn
  createDate
  passwordLastUsed
  path
  permissionsBoundary
  tags
  userName
}

"""An edge in a connection"""
type PodEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Pod
}

"""Account Level Metrics Info type"""
type AccountMetrics {
  count: Int
  """Total logical size"""
  logicalSize: Quantity
  """Total logical size in base 10"""
  logicalSizeBase10: Quantity
  """Total logical size in MiB"""
  logicalSizeInMiB: Int
  """Total physical size"""
  physicalSize: Quantity
  """Total physical size in base 10"""
  physicalSizeBase10: Quantity
  """Total physical size in MiB"""
  physicalSizeInMiB: Int
}

"""A gateway object for the SupportAssist object."""
input SupportAssistGatewayInput {
  """A string representing an IP or DNS-resolvable name for the gateway"""
  hostname: String!
  """
  An integer corresponding to the port on the hostname where the gateway operates. (1-65535)
  """
  port: Int
  """
  An integer representing the priority of the gateway. 1 is highest priority. (1-1000)
  """
  priority: Int
}

"""Comparison operator used to test fields against values"""
enum Operator {
  """Equality"""
  eq
  """Greater than"""
  gt
  """Less than"""
  lt
  """Less than or equal to"""
  lte
  """Excluded from list"""
  notin
  """Inequality"""
  ne
  """Greater than or equal to"""
  gte
  """Included in list"""
  in
  """String contains"""
  contains
  """String excludes"""
  excludes
  """String begins with"""
  beginswith
}

"""Changes the sort order of nodes returned in a connection"""
input NotifierSort {
  """Name of field on which to sort the connection"""
  field: NotifierSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""
A VMware StoragePool used to evaluate storage capacity resources by node and storage class
"""
type StoragePool implements Node {
  """Names of all nodes in the cluster that can access this storage pool"""
  accessibleNodes: [String]
  """
  Names of all storage classes in the cluster can be provisioned from this storage pool
  """
  compatibleStorageClasses: [String]
  """
  URL showing location of the vSphere datastore which backs this storage pool
  """
  dataStoreURL: String
  """Full error message indicating an error condition on the storage pool"""
  errorMessage: String
  """Short string indicating an error condition on the storage pool"""
  errorState: String
  """The amount of free space remaining in the pool"""
  freeSpace: Quantity
  """The amount of free space remaining in the pool"""
  freeSpaceBase2: Quantity
  """The amount of free space remaining in the pool in MiB"""
  freeSpaceInMiB: Int
  """The ID of an object"""
  id: ID!
  """Unique name of the storage pool"""
  name: String
  """Represents the type of vSphere vSAN storage pool."""
  poolType: String
  """The total amount of capacity in the pool"""
  totalCapacity: Quantity
  """The total amount of capacity in the pool"""
  totalCapacityBase2: Quantity
  """The total amount of capacity in the pool in MiB"""
  totalCapacityInMiB: Int
}

"""Changes the sort order of nodes returned in a connection"""
input BucketSort {
  """Name of field on which to sort the connection"""
  field: BucketSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""
A Kubernetes StoragePool used to evaluate storage capacity resources by node and storage class
"""
type SizerStoragePool {
  """Names of all nodes in the cluster that can access this storage pool"""
  accessibleNodes: [String]
  """
  Names of all storage classes in the cluster can be provisioned from this storage pool
  """
  compatibleStorageClasses: [String]
  """The amount of free space remaining in the pool in MiB"""
  freeSpaceInMiB: Int
  """Unique name of the storage pool"""
  name: String
}

"""An expressions used to match a pod label"""
input MatchExpressionInput {
  """Label key to match against"""
  key: String
  """Operator to use in value comparisons"""
  operator: String
  """List of label values to compare against"""
  values: [String]
}

"""TLS Certificate for HTTPS endpoints"""
input CertificateSigningRequestInput {
  """Certificate common name"""
  commonName: String
  """Certificate contact email address"""
  email: String
  """Names used to sign this certificate"""
  names: CertificateNamesInput
  """Algorithm used to generate key"""
  keyAlgorithm: String
  """Size of the key in bits"""
  keySize: Int
}

"""An edge in a connection"""
type ObjectStoreTemplateEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: ObjectStoreTemplate
}

"""
Performance information per requested period (default period last 24 hour)
"""
type Latency {
  """Read first byte (p50) latency value in milliseconds"""
  readFirstByteInMSp50: LatencyData
  """Read first byte (p90) latency value in milliseconds"""
  readFirstByteInMSp90: LatencyData @deprecated(reason: "This field contains a typo in the name. Use 'readFirstByteInMSp99'")
  """Read first byte (p99) latency value in milliseconds"""
  readFirstByteInMSp99: LatencyData
  """Write last byte (p50) latency value in milliseconds"""
  writeLastByteInMSp50: LatencyData
  """Write last byte (p90) latency value in milliseconds"""
  writeLastByteInMSp90: LatencyData @deprecated(reason: "This field contains a typo in the name. Use 'writeLastByteInMSp99'")
  """Write last byte (p99) latency value in milliseconds"""
  writeLastByteInMSp99: LatencyData
}

type condition {
  severityType: String
  thresholdUnits: String
  thresholdValue: String
}

"""Bucket and object level metering statistics"""
type Metering {
  """The total number of buckets in this object store/object scale"""
  bucketCount: Int
  """The compression ratio realized for this object store/object scale"""
  compressionRatio: String
  """The total number of objects in this object store/object scale"""
  objectCount: Int
  """The total number of deleted objects from the object store/object scale"""
  objectDeletedCount: Int
  """The amount of capacity occupied by deleted objects in binary SI"""
  objectDeletedSize: Quantity
  """The amount of capacity occupied by deleted objects in decimal SI"""
  objectDeletedSizeBase10: Quantity
  """The amount of capacity occupied by deleted objects in MiB"""
  objectDeletedSizeInMiB: Int
  """The amount of capacity consumed by end user applications in binary SI"""
  objectSize: Quantity
  """The amount of capacity consumed by end user applications in decimal SI"""
  objectSizeBase10: Quantity
  """The amount of capacity consumed by end user applications in MiB"""
  objectSizeInMiB: Int
  """
  The physical drive capacity consumed to store the application data in binary SI
  """
  objectSizePhysical: Quantity
  """
  The physical drive capacity consumed to store the application data in decimal SI
  """
  objectSizePhysicalBase10: Quantity
  """
  The physical drive capacity consumed to store the application data in MiB
  """
  objectSizePhysicalInMiB: Int
  """A list of all object stores targeted for replication"""
  replication: ReplicationDetailsType
  """The number of objects that have replicated to this bucket scale"""
  replicationObjectCount: Int
  """
  The amount of application data replicated to this bucket scale in binary SI
  """
  replicationObjectSize: Quantity
  """
  The amount of application data replicated to this bucket scale in decimal SI
  """
  replicationObjectSizeBase10: Quantity
  """The amount of application data replicated to this bucket scale in MiB"""
  replicationObjectSizeInMiB: Int
  """
  The physical drive capacity consumed to store application data replicated to this bucket scale in binary SI
  """
  replicationObjectSizePhysical: Quantity
  """
  The physical drive capacity consumed to store application data replicated to this bucket scale in decimal SI
  """
  replicationObjectSizePhysicalBase10: Quantity
  """
  The physical drive capacity consumed to store application data replicated to this bucket scale in MiB
  """
  replicationObjectSizePhysicalInMiB: Int
}

"""Changes the sort order of nodes returned in a connection"""
input StorageClassSort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: StorageClassSortableField
}

input ObjectLockConfigurationInput {
  """The rule for this object lock."""
  retention: ObjectLockConfigurationRule
  """Whether or not the object lock is enabled."""
  enabled: Boolean
}

"""The input to set a Tenant's quota."""
input SetTenantQuotaInput {
  notificationSizeInCount: String
  objectStore: NamespacedNameInput
  accountID: String
  blockSize: String
  notificationSize: String
  blockSizeInCount: String
}

"""Fields sortable for persistent volume field"""
enum PersistentVolumeSortableField {
  name
  creationTimestamp
  storageClassName
  message
  namespace
  readiness
  size
  capacity
  status
  reclaimPolicy
  reason
  createdTimestamp
}

"""A pod affinity rule used in affinity or anti-affinity definitions"""
type AffinityTerm {
  """Selector used to affinitize or anti-affinitize this pod to other pods"""
  labelSelector: LabelSelector
  """
  Node label used to identify specific groups of nodes for affinity or anti-affinity
  """
  topologyKey: String
}

input SupportAssistConfigEditInput {
  """SupportAssist fields to configure the resource."""
  configuration: SupportAssistConfigInput!
}

"""Service or job to check on the status of a Kubernetes applicaion"""
type Healthchecks {
  """Description of the health check"""
  description: String
  """Whether this health check is enabled to run on its schedule"""
  enabled: Boolean
  """Date and time of the latest unsuccessful completion"""
  latestFailure: String
  """Date and time of the latest successful completion"""
  latestSuccess: String
  """description of the test result"""
  message: String
  """Name of the health check"""
  name: String
  """Schedule for the health check to run"""
  schedule: String
}

"""Changes the sort order of nodes returned in a connection"""
input GroupSort {
  """Name of field on which to sort the connection"""
  field: GroupSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""A connection to a list of items."""
type IAMSAMLProviderConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [IAMSAMLProviderEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

input NamespaceAccessListInput {
  """The name of the namespace a user has access"""
  name: String!
  """The granted role level to the namespace"""
  role: String!
}

"""Specifies replication time"""
input ReplicationTimeValueInputType {
  """Not implemented. The amount of replication time in minutes"""
  minutes: Int!
}

"""KAHM events"""
type Event implements Node {
  """Has the event been acknowledged by an administrator"""
  acknowledged: Boolean
  """The name of the application that issued the event"""
  applicationName: String
  """The component that have the event"""
  component: String
  """The total number of the time this event is repeated"""
  count: Int
  """The time and date when the event was created"""
  createdOn: DateTime
  """The ID of an object"""
  id: ID!
  """The labels are contained by the component"""
  labels: [Labels]
  """The information of the event"""
  message: String
  """The application is deployed at this namespace"""
  namespace: String
  """The description of the reason of the issued event"""
  reason: String
  """...."""
  related: String
  """What can be done to repair the event"""
  remedies: [String]
  """The kubernetes resource on which the event is active"""
  resourceID: String
  """The id of the event"""
  symptomID: String
  """The type of the event"""
  type: EventTypes
  """The time and date when the event was updated"""
  updatedOn: DateTime
}

"""SRS Gateway"""
type SRSGateway {
  """Indiciates if the gateway is currently disabled"""
  disabled: Boolean
  """SRS Gateway host"""
  gatewayHost: String
  """SRS Gateway user password"""
  gatewayPassword: String
  """SRS Gateway port"""
  gatewayPort: Int
  """SRS Gateway serial number"""
  gatewaySerialNumber: String
  """SRS Gateway username"""
  gatewayUsername: String
  """The ID of an object"""
  id: ID!
  name: String
  namespace: String
  """Error while reconciling"""
  reconcileError: String
  """Registered means we have registered with the SRS Gateway"""
  registered: Boolean
  """Remote Access external IP"""
  remoteAccessExternalIP: String
  """Remote Access user password"""
  remoteAccessPassword: String
  """Remote Access username"""
  remoteAccessUsername: String
  """Product serial number"""
  serialNumber: String
  """Indiciates the status of the gateway"""
  state: SRSGatewayState
  """Result of SRS Call Home test"""
  testDialHomeResult: String
  """Last time SRS call Home test is performed"""
  testDialHomeTime: String
}

"""The bucket quota object"""
type BucketQuota {
  blockCounts: Int
  blockSize: Int
  bucketName: String
  namespace: String
  notificationCounts: Int
  notificationSize: Int
}

"""list of healthchecks"""
type HealthCheckData {
  """Health check definitions"""
  spec: Healthcheck
  """Results of each health check"""
  status: HealthCheckStatus
}

"""
Kubernetes workload resource settings to request or limit resources used on a node
"""
type Resources {
  """Resource request for resource"""
  limits: [StringQuantityMap]
  """Resource request for resource"""
  requests: [StringQuantityMap]
}

type PodAffinityPreferredTerm {
  podAffinityTerm: AffinityTerm
  """Priority to give this preferred affinity rule"""
  weight: Int
}

"""An edge in a connection"""
type FedObjectStoreEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: FedObjectStore
}

input LicenseInput {
  """The license data (String)"""
  license: String
}

"""An amount of consumable node resource: storage, CPU, memory, etc."""
type Quantity {
  """The measurement unit of the quantity: Ki, Mi, millicores, etc."""
  unit: String
  """The amount of on the quantity as a number"""
  value: Float
}

"""The notification configuration set on the bucket"""
type TopicConfigurationType {
  events: [String]
  """Filter rules for the events chosen"""
  filter: [FilterRuleType]
  id: String
  topicARN: String
}

"""Provision of CPU and Memory Resource"""
type ResourceProvision {
  """CPU Limit of a object store"""
  cpuLimit: Quantity
  """CPU Limit of a object store in Milli cores"""
  cpuLimitInMilli: Int
  """CPU Request of a object store"""
  cpuRequest: Quantity
  """CPU Request of a object store in Milli cores"""
  cpuRequestInMilli: Int
  """Memory Limit of a object store"""
  memoryLimit: Quantity
  """Memory Limit of a object store in kilobytes"""
  memoryLimitInKB: Int
  """Memory Request of a object store"""
  memoryRequest: Quantity
  """Memory Request of a object store in Kilobytes"""
  memoryRequestInKB: Int
  """Storage limit of an object store"""
  storageLimit: Quantity
  """Storage limit an object store in Megabytes"""
  storageLimitInMB: Int
  """Requested storage by an object store"""
  storageRequest: Quantity
  """Requested storage by an object store in Megabytes"""
  storageRequestInMB: Int
}

"""Settings for the license configuration"""
type LicenseV2 {
  """The user who activated the license"""
  activatedBy: String
  """The company which activated the license"""
  activationCompany: String
  """The date when the license was activated"""
  activationDate: String
  """The activation ID for the license"""
  activationID: String
  """The Site ID associated with this license"""
  activationSiteID: String
  """Entitlement Software ID"""
  enterpriseSoftwareID: String
  """List of features"""
  features: [FeatureV2]
  """The ID of an object"""
  id: ID!
  """Instance Software ID (Serial Number)"""
  instanceSoftwareID: String
  name: String
  namespace: String
}

"""An edge in a connection"""
type AttachedPolicyEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: AttachedPolicy
}

input IAMDeletePolicyVersionInput {
  """The name of the version to delete"""
  PolicyVersion: String!
  """The accountID in plaintext"""
  account: String!
  """
  The ARN related to the IAM Policy which should have the version deleted
  """
  ARN: String!
}

"""Resource CPU and Memory Utilization"""
type ResourceUsage {
  """CPU utilization of this resource as a quantity"""
  cpuConsumed: Quantity
  """CPU utilization of this resource in millicores"""
  cpuConsumedInMilli: Int
  """Memory utilization of this resource as a quantity"""
  memoryConsumed: Quantity
  """Memory utilization of this resource in kilobytes"""
  memoryConsumedInKB: Int
  """Storage utilization of this resource as a quantity"""
  storageConsumed: Quantity
  """Storage utilization of this resource in megabytes"""
  storageConsumedInMB: Int
  """Timestamp of the metric value"""
  timestamp: String
  """The window in which the metric was gathered"""
  window: String
}

"""Fields sortable for group field"""
enum GroupSortableField {
  name
}

"""An object user secret key"""
type ObjectUserSecretKeyType {
  """An Object user name"""
  objectUserName: String
  """A secret key"""
  objectUserSecretKey: ObjectUserSecretKey
}

"""A connection to a list of items."""
type PodConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The field name for the summation"""
    values: [String]
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [PodEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Stateful set resources that are owned by an ECS cluster"""
type StatefulSet implements Node & KubernetesResource {
  creationTimestamp: String
  """The ID of an object"""
  id: ID!
  kind: String
  """Labels that are assigned to the stateful-set"""
  labels: [Labels]
  """Stateful-set Name"""
  name: String
  """Stateful-set Namespace"""
  namespace: String
  readiness: String
  """Current replicas of the stateful-set"""
  replicas: Int
  size: Quantity
  sizeResource: String
}

input ExternalConnectionInput {
  """Connection details for the external service"""
  externalConnection: NetworkConnectionInput
  """Namespace it resides in"""
  namespacedName: NamespacedNameInput
}

input DeleteIAMRolePolicyInput {
  """The name of the policy document"""
  policyName: String!
  """The account where resource created"""
  accountID: String!
  """The name of the role to delete"""
  roleName: String!
}

"""Kubernetes Notifier"""
type Notifier implements Node {
  available: Boolean
  grpcConnTimeout: Int
  grpcRetries: Int
  hostname: String
  """The ID of an object"""
  id: ID!
  name: String
  namespace: String
  port: Int
  totalEventsDelivered: Int
}

"""A connection to a list of items."""
type HealthCheckConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [HealthCheckEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

enum CertificateStatus {
  KubernetesCertificateApproved
  KubernetesCertificateInstalled
  KubernetesCertificateDenied
  InternalCASignedCertificateInstalled
  Started
  ExternalCertificateInstalled
  SelfSignedCertificateInstalled
  KubernetesCertificateRequested
}

"""A kubernetes label from application resource"""
type label {
  key: String
  value: String
}

"""Configuration specification of an object-store"""
type ObjectStoreSpec {
  """Atlas component specification"""
  atlas: ObjectStoreComponentSpec
  """Blob component specification"""
  blob: ObjectStoreComponentSpec
  """Bookkeeper component specification"""
  bookkeeperIndex: ObjectStoreComponentSpec
  """Bookkeeper component specification"""
  bookkeeperJournal: ObjectStoreComponentSpec
  """Bookkeeper component specification"""
  bookkeeperLedger: ObjectStoreComponentSpec
  """ChunkManager component specification"""
  chunkManager: ObjectStoreComponentSpec
  """Control component specification"""
  control: ObjectStoreComponentSpec
  """controlPlane component specification"""
  controlPlane: ObjectStoreComponentSpec
  """DEOSEvents component specification"""
  deosEvents: ObjectStoreComponentSpec
  """Diagnostic component specification"""
  diagnostic: ObjectStoreComponentSpec
  """Object-store event component specification"""
  event: ObjectStoreComponentSpec
  """Fluxd component specification"""
  fluxd: ObjectStoreComponentSpec
  """GeoReceiver component specification"""
  geoReceiver: ObjectStoreComponentSpec
  """geoService component specification"""
  geoService: ObjectStoreComponentSpec
  """Grafana component specification"""
  grafana: ObjectStoreComponentSpec
  """InfluxDB component specification"""
  influxDB: ObjectStoreComponentSpec
  """ManagementGateway component specification"""
  managementGateway: ObjectStoreComponentSpec
  """Metering component specification"""
  metering: ObjectStoreComponentSpec
  """nds component specification"""
  nds: ObjectStoreComponentSpec
  """ObjectStore Metering"""
  objectStoreMetering: ObjectStoreComponentSpec
  """Object service component specification"""
  objectsvc: ObjectStoreComponentSpec
  """ons component specification"""
  ons: ObjectStoreComponentSpec
  """pravegaController component specification"""
  pravegaController: ObjectStoreComponentSpec
  """Profile for the object-store"""
  profile: Profile
  """RecordManager component specification"""
  recordManager: ObjectStoreComponentSpec
  """rep component specification"""
  rep: ObjectStoreComponentSpec
  """Resource component specification"""
  resource: ObjectStoreComponentSpec
  """S3 component specification"""
  s3: ObjectStoreComponentSpec
  """segmentStore component specification"""
  segmentStore: ObjectStoreComponentSpec
  """SpaceReclaimer component specification"""
  spaceReclaimer: ObjectStoreComponentSpec
  """StorageManagement component specification"""
  storageManagement: ObjectStoreComponentSpec
  """StorageServer component specification"""
  storageServer: ObjectStoreComponentSpec
  """StorageServerManager component specification"""
  storageServerManager: ObjectStoreComponentSpec
  """Telegraf component specification"""
  telegraf: ObjectStoreComponentSpec
  """Throttler component specification"""
  throttler: ObjectStoreComponentSpec
  """Zookeeper component specification"""
  zookeeper: ObjectStoreComponentSpec
}

type SizerClusterResourceType {
  """The k8s node allocatable cpu"""
  cpu: Quantity
  """The k8s node allocatable memory"""
  memory: Quantity
}

input LegalHoldBucketConfiguration {
  """The name of the bucket to create."""
  bucketName: String!
  """The relay ID of the tenant to create a new bucket for."""
  tenantID: ID!
}

"""Selects modifications on replicas"""
input SourceSelectionCriteriaInput {
  """Not implemented. Filter for replication modifications on replicas"""
  status: String
}

"""Encryption configuration for destination bucket for object replication"""
input EncryptionConfigurationInputType {
  """Not implemented. The ARN for the destination bucket"""
  replicaKmsKeyID: String
}

"""
A filter that identifies the subset of objects to which the replication rule applies
"""
input RuleFilterInputType {
  """
  An object key name prefix identifier for objects to which the rule applies
  """
  prefix: String
  """A list of containers for specifying a tag key and value"""
  tag: [TagInput]
}

"""Results from health checks"""
type HealthCheckResults {
  """Date and time of the latest unsuccessful completion"""
  lastFailure: String
  """Date and time of the latest successful completion"""
  lastSuccess: String
  """Description of the test result"""
  message: String
  """Name of subtest within the health check container"""
  name: String
  """Pass or Fail status of internal check"""
  passed: Boolean
}

"""A connection to a list of items."""
type AccountConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [AccountEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type values {
  fieldName: String!
  floatValue: Float
  integerValue: Int
  quantityValue: Quantity
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

"""Changes the sort order of nodes returned in a connection"""
input TenantSort {
  """Name of field on which to sort the connection"""
  field: TenantSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""Object store storage usage"""
type StorageConsumedType {
  """Available storage"""
  available: String
  """If node is offline"""
  offline: String
  """Amount of storage reserved"""
  reserved: String
  """Total storage"""
  total: String
  """Amount of storage currently in use"""
  used: String
}

"""A connection to a list of items."""
type IAMListGroupForUserConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The field name for the summation"""
    values: [String]
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [IAMListGroupForUserEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A connection to a list of items."""
type AttachedGroupUsersConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [AttachedGroupUsersEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type groups {
  category: String
  count: Int
  group: String
  values: [values]
}

"""A connection to a list of items."""
type BucketConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [BucketEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type SizerStorageClass {
  hostLocal: Boolean!
  name: String!
  poolType: String!
}

input ObjectUserSecretKeyInputDelete {
  """Namespaced name of the objectStore in which this object user resides"""
  objectStore: NamespacedNameInput
  """The objectUserSecretKey to be deleted"""
  objectUserSecretKey: ObjectUserDeleteSecretKeyTypeInput!
}

"""Labels that are assigned to the resource"""
type Labels {
  """The name of the labelType"""
  key: String
  """The value of the labelType"""
  value: String
}

enum UseCaseType {
  General
  Archive
  InternetOfThings
  Performance
}

input PutObjectLockPolicyInput {
  """The configuration for the lock to apply."""
  configuration: ObjectLockConfigurationInput!
  """The bucket relay ID to put the object lock onto."""
  bucket: ObjectLockBucketConfiguration!
  """A field of acknowledgement for paid requests. """
  requestPayer: String!
  """A token to allow Object Lock to be enabled for an existing bucket."""
  token: String
}

"""A connection to a list of items."""
type GroupConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [GroupEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type AccountAccessKey implements Node {
  """The access key id"""
  accessKeyId: String!
  """The date the access key was created"""
  createDate: DateTime!
  """The ID of an object"""
  id: ID!
  """The secret access key"""
  secretAccessKey: String
  """The status of the access key"""
  status: String!
}

input ObjectUserSecretKeyInput {
  """Namespaced name of the objectStore in which this object user resides"""
  objectStore: NamespacedNameInput
  """The objectUserSecretKey to be created"""
  objectUserSecretKey: ObjectUserSecretKeyTypeInput!
}

"""Destination to publish analysis or configuration results"""
input DestinationInputType {
  """Storage class to use when replicating objects"""
  storageClass: String
  """Change the replica ownership in a cross-account scenario"""
  ownerOverride: Boolean
  """Destination bucket owner account ID for change replica ownership"""
  account: String
  """ARN of the bucket to store results in"""
  bucket: String!
  """Not implemented. Provides information about encryption"""
  encryptionConfiguration: EncryptionConfigurationInputType
  """
  Not implemented. Replication metrics-related settings enabling replication
  """
  metrics: MetricsInput
  """Not implemented. S3 Replication Time Control information (S3 RTC)"""
  replicationTime: ReplicationTimeInputType
}

"""An object with an ID"""
interface Node {
  """The id of the object"""
  id: ID!
}

"""An edge in a connection"""
type FederatedObjectStoreEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: FederatedObjectStore
}

"""An object lock rule configuration associated with a bucket."""
type ObjectLockRuleConfiguration {
  retention: ObjectLockRule
}

"""Information about installed settings"""
type SizingOutput {
  """Calculated node capacity"""
  calculatedNodeCapacity: Quantity
  """Calculated node count"""
  calculatedNodeCount: Int
  """Calculated performance profile"""
  calculatedProfile: Profile
  """Breakdown of capacity utilization by usage"""
  capacityUsageBreakdown: [StringQuantityMap]
  """Breakdown of capacity utilization by workload"""
  capacityWorkloadBreakdown: [StringQuantityMap]
  """Required capacity for the object store"""
  cpu: Quantity
  """
  Maximum capacity supported by the configured object-store with current configuration
  """
  maximumPotentialCapacity: Quantity
  """
  Maximum transactions per second supported by object-store with current configuration
  """
  maximumPotentialTransactions: Int
  """Required capacity for the object store"""
  memory: Quantity
  """Breakdown of capacity utilization by usage"""
  performanceUsageBreakdown: [StringQuantityMap]
  """Breakdown of capacity utilization by workload"""
  performanceWorkloadBreakdown: [StringQuantityMap]
  """Recommended node capacity"""
  recommendedNodeCapacity: Quantity
  """Recommended node count"""
  recommendedNodeCount: Int
  """Recommended performance profile"""
  recommendedProfile: Profile
  """Required capacity for the object store"""
  requiredCapacity: Quantity
  """
  Estimate of the transactions per second supported by the sized object store
  """
  transactionRate: Int
  """
  number of years this store can scale based on the projected growth rate
  """
  yearsOfGrowth: Int
}

"""A connection to a list of items."""
type IssueConnection {
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [IssueEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A kubernetes node"""
type ClusterNode implements Node {
  age: String
  """The allocatable resource for cluster node"""
  allocatable: ResourceType
  available: Boolean
  availableStorage: Quantity
  """The capacity resource for cluster node"""
  capacity: ResourceType
  externalIP: String
  externalStorageFree: Quantity
  externalStorageTotal: Quantity
  faultDomainValue: String
  """The ID of an object"""
  id: ID!
  internalIP: String
  internalStorageFree: Quantity
  internalStorageTotal: Quantity
  k8sversion: String
  kernelversion: String
  """Returns a list of label for node"""
  labels(last: Int, source: FilterStringArgument, key: FilterStringArgument, value: FilterStringArgument, offset: Int, sort: ClusterNodeSort, before: String, after: String, first: Int): NodeLabelConnection
  name: String
  osimage: String
  role: String
  """Returns a list of Kubernetes StoragePools"""
  storagepools(name: FilterStringArgument, totalCapacityInMiB: FilterIntegerArgument, before: String, after: String, first: Int, last: Int, dataStoreURL: FilterStringArgument, accessibleNodes: FilterStringArgument, compatibleStorageClasses: FilterStringListArgument, freeSpaceInMiB: FilterIntegerArgument, errorState: FilterStringListArgument, errorMessage: FilterStringArgument, offset: Int, poolType: FilterStringArgument, sort: StoragePoolSort): StoragePoolConnection
  totalStorage: Quantity
}

"""An edge in a connection"""
type PersistentVolumeEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: PersistentVolume
}

"""An object store tenant instance"""
type TenantCreate {
  alias: String
  blockSize: String
  blockSizeInCount: String
  default_bucket_block_size: Int
  default_data_services_vpool: String
  id: String
  is_compliance_enabled: Boolean
  is_encryption_enabled: Boolean
  notificationSize: String
  notificationSizeInCount: String
  retention_classes: String
}

"""Results output fields"""
input ObjectStoreOutputType {
  memory: QuantityInput!
  """
  The signature of the sizing request as given by sizer. This is the same as the RequestSizing ID.
  """
  signature: String
  requiredCapacity: QuantityInput!
  transactionRate: Int!
  maximumPotentialCapacity: QuantityInput!
  maximumPotentialTransactions: Int!
  cpu: QuantityInput!
}

"""
The replication configuration destination for the replication configuration rule
"""
type ReplicationDestinationType {
  account: String
  bucket: String
  ownerOverride: Boolean
  storageClass: String
}

enum EventTypes {
  Normal
  Warning
  Error
  Critical
  Audit
}

"""Affinity rules used to direct workloads within Kubernetes cluster"""
input AffinityInput {
  """Pod affinity rules"""
  podAffinity: PodAffinityTermInputType
  """Pod AntiAffinity rules"""
  podAntiAffinity: PodAffinityTermInputType
}

input IAMPolicyCreateInput {
  """The JSON document containing all of the policy information"""
  document: String!
  """The ARN of the iam policy to create a new policy for"""
  name: String!
  """The human-friendly description of the policy"""
  description: String
  """The path for the policy. Defaults to '/'"""
  path: String
  """The accountID in plaintext"""
  account: String!
}

input ManagerUpgradeInput {
  """The version to upgrade Manager to"""
  version: String!
}

"""Helm chart package available in the repository"""
type HelmChart implements Node {
  """
  Annotations are additional mappings uninterpreted by Helm made available for inspection by other applications
  """
  annotations: Annotation
  """The API Version of this chart."""
  apiVersion: String
  """The version of the application enclosed inside of this chart."""
  appVersion: String
  """Returns a list of Kubernetes HelmCharts"""
  chartVersions(before: String, description: FilterStringArgument, icon: FilterStringArgument, tags: FilterStringArgument, allVersions: Boolean, type: FilterStringArgument, first: Int, condition: FilterStringArgument, appVersion: FilterStringArgument, kubeVersion: FilterStringArgument, offset: Int, name: FilterStringArgument, sources: FilterStringListArgument, keywords: FilterStringListArgument, apiVersion: FilterStringArgument, sort: HelmChartSort, after: String, home: FilterStringArgument, version: FilterStringArgument, deprecated: FilterBooleanArgument, last: Int): HelmChartConnection
  """The condition to check to enable chart"""
  condition: String
  """Whether or not this chart is deprecated"""
  deprecated: Boolean
  """A one-sentence description of the chart"""
  description: String
  """The URL to a relevant project page, git repo, or contact person"""
  home: String
  """The URL to an icon file."""
  icon: String
  """The ID of an object"""
  id: ID!
  """A list of string keywords"""
  keywords: [String]
  """
  KubeVersion is a SemVer constraint specifying the version of Kubernetes required.
  """
  kubeVersion: String
  """The name of the chart"""
  name: String
  """Source is the URL to the source code of this chart"""
  sources: [String]
  """The tags to check to enable chart"""
  tags: String
  """Type specifies the chart type: application or library"""
  type: String
  """A SemVer 2 conformant version string of the chart"""
  version: String
}

"""Names used to sign this certificate"""
type Issuer {
  """Common name of the certificate issuer CA"""
  commonName: String
  """Country of origin for certificate signer"""
  country: String
  """Locality of origin (city, town, county, etc.) for certificate signer"""
  locality: String
  """Organization signing this certificate"""
  organization: String
  """Organization unit (department) signing this certificate"""
  organizationalUnit: String
  """State or province of origin for certificate signer"""
  state: String
}

"""An edge in a connection"""
type ServiceEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Service
}

"""Fields sortable for SRS gateway field"""
enum SRSGatewaySortableField {
  gatewayPassword
  remoteAccessUsername
  remoteAccessPassword
  registered
  testDialHomeResult
  serialNumber
  testDialHomeTime
  reconcileError
  gatewayUsername
  gatewayHost
  gatewayPort
  remoteAccessExternalIP
  gatewaySerialNumber
}

"""A connection to a list of items."""
type LicenseConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [LicenseEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Changes the sort order of nodes returned in a connection"""
input AttachedPolicySort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: AttachedPolicySortableField
}

input S3BucketCreationInput {
  """An XML document representing the Access Control List for the bucket."""
  ACL: String
  """Enable server-side encryption for this bucket."""
  encryptionEnabled: Boolean
  """The region for the bucket creation."""
  region: String = "us-west-2"
  """An optional list of those who have all access to this bucket"""
  fullControlACL: String
  """An optional list of those with read access to bucket objects"""
  grantRead: String
  """An optional list of those with write access to bucket objects."""
  grantWrite: String
  """An optional list of those who can write to the ACL"""
  grantWriteACP: String
  """The tenant ID is used to namespace a bucket during creation"""
  tenantID: ID!
  """The bucket to be created"""
  name: String!
  """Whether or not object lock is enabled"""
  objectLock: Boolean
  """An optional list of those who can view the ACL"""
  grantReadACP: String
}

"""Network protocol"""
enum NetworkProtocol {
  udp
  http
  https
  tcp
}

"""An edge in a connection"""
type StatefulSetEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: StatefulSet
}

input ObjectLockBucketConfiguration {
  """The relay ID of the tenant to create a new bucket for."""
  tenantID: ID!
  """The name of the bucket to create."""
  bucketName: String!
}

"""Annotation of a resource"""
type Annotation {
  """The name of the AnnotationType"""
  name: String
  """The value of the AnnotationType"""
  value: String
}

"""An ECS object storage cluster instance"""
type Bucket implements Node {
  auditDeleteExpiration: Int
  blockCounts: Int
  blockSize: Int
  creationTime: String
  defaultRetention: Int
  encryptionEnabled: Boolean
  """The ID of an object"""
  id: ID!
  metering: BucketMeteringType
  name: String
  notificationConfiguration: NotificationConfigurationType
  notificationCounts: Int
  notificationSize: Int
  """Returns a legal hold on a bucket object."""
  objectLegalHold(
    """fields applied to update bucket"""
    input: GetLegalHoldInput!
  ): LegalHoldConfiguration
  """Returns a list of locks on a bucket"""
  objectLock: ObjectLockConfiguration
  owner: String
  policy: String
  replicationConfiguration: BucketReplicationConfigurationType
  retention: Int
  versioning: String
}

"""An edge in a connection"""
type TrustedAnchorsEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: TrustedAnchors
}

"""Changes the sort order of nodes returned in a connection"""
input KubernetesResourceSort {
  """Name of field on which to sort the connection"""
  field: KubernetesResourceSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

input BucketCreationInput {
  """The tenant ID is used to namespace a bucket during creation"""
  tenantID: ID!
  """Namespaced name of the objectStore in which this bucket resides"""
  objectStore: NamespacedNameInput!
  """The bucket to be created"""
  name: String!
  """The bucket policy to be applied"""
  policy: String
  """Versioning status of bucket"""
  enableVersioning: Boolean = false
  """the bucket size at which the users will be notified"""
  notificationSize: Int
  """the bucket size at which new object creations will be blocked"""
  blockSize: Int
  """Whether or not object lock is enabled"""
  objectLock: Boolean
  """Encryption status of bucket"""
  encryptionEnabled: Boolean = false
}

"""A connection to a list of items."""
type PersistentVolumeClaimConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [PersistentVolumeClaimEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection"""
type RemoteInstanceEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: RemoteInstance
}

"""Changes the sort order of nodes returned in a connection"""
input NamespaceSort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: NamespaceSortableField
}

"""Fields sortable for namespace field"""
enum NamespaceSortableField {
  name
}

"""A Kubernetes namespace used to logically group resources"""
type Namespace implements Node {
  """The ID of an object"""
  id: ID!
  name: String
}

"""Changes the sort order of nodes returned in a connection"""
input InlinePolicySort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: InlinePolicySortableField
}

input DeleteAccountAccessKeyInput {
  """A unique identifier for this account"""
  accountID: String!
  """Deprecated in favor of new accountID field"""
  AccountId: String
  """A unique identifier for this account access key"""
  accessKeyId: String!
}

"""Changes the sort order of nodes returned in a connection"""
input AlertPolicySort {
  """Name of field on which to sort the connection"""
  field: AlertPolicySortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""An edge in a connection"""
type SRSGatewayEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: SRSGateway
}

"""Feature"""
type Feature {
  """Code of this feature"""
  code: String
  """Name of the License feature"""
  name: String
  """Usage of this feature"""
  usage: Int
}

input CreateWebhookConfigurationType {
  """Webhook backup limit"""
  backupLimit: String
  """Optional comment to attach to the webhook"""
  comment: String
  """Endpoint for the webhook to send to"""
  endpoint: String!
  """AccountID to use for the DCM mutation"""
  accountID: String!
  """Webhook name"""
  name: String!
  """Auth token for the webhook"""
  authToken: String!
}

"""An object store alert policy condition input instance"""
input AlertPolicyConditionInput {
  """Type of value for the threshold value of the alert policy"""
  thresholdUnits: String
  """Threshold value limit of the alert policy"""
  thresholdValue: String
  """Severity type of the alert policy. Warning, Critical, etc"""
  severityType: String
}

"""A single key value pair."""
type Tag {
  """custom key"""
  key: String
  """custom value"""
  value: String
}

"""A notifier resource"""
type NotifierConfigType {
  available: Boolean
  grpcConnTimeout: Int
  grpcRetries: Int
  hostname: String
  """The ID of an object"""
  id: ID!
  name: String
  namespace: String
  port: Int
  totalEventsDelivered: Int
}

type PermissionBoundary {
  createDate: DateTime
  name: String
  permissionsBoundaryARN: String
  permissionsBoundaryType: String
  updateDate: DateTime
}

type SizingResult {
  """The ID of an object"""
  id: ID!
  inputs: SizingInput
  objectStoreSpec: ObjectStoreSpec
  outputs: SizingOutput
}

"""The IAM SAML Provider information"""
type IAMSAMLProvider {
  """The Amazon Resource Name (ARN) specifying the SAML provider"""
  arn: String
  """The human-friendly Name of the SAML provider"""
  created: DateTime
  """The document containing the SAML metadata"""
  document: String
  """The date that the provider is valid until"""
  expiry: DateTime
  """The ID of an object"""
  id: ID!
  """An optional list of tags to attach to the provider"""
  tags: [Tag]
}

input FilterRule {
  """The prefix and suffix filters to use for events watching"""
  name: String
  """The value of the filter key to watch for"""
  value: String
}

input CertificateInput {
  """The password attached to the certificate (optional)"""
  certificatePassword: String
  """
  The private key that corresponds with the public key in the certificate
  """
  privateKey: String
  """Name and namespace of the application the certificate applies to"""
  application: NamespacedNameInput
  """The name of certificate to upload"""
  certificateName: String
  """The certificate to upload"""
  certificate: String
  """The root certificate authority (optional)"""
  rootCA: String
  """The intermediate certificate authority (optional)"""
  intermediateCA: String
}

input DeleteLicenseInput {
  """the name of the license resource to delete"""
  name: String
}

input AttachIAMRolePolicyInput {
  """The account id of the role"""
  accountID: String!
  """The name of the role to attach the policy"""
  roleName: String!
  """The name of the policy to attach to the role"""
  policyArn: String!
}

"""Settings for the SupportAssist configuration"""
type SupportAssist implements Node {
  """AccessKey used to register for SupportAssist."""
  accessKey: String
  """Customer contact details for the SupportAssist"""
  customerContacts: [CustomerContact]
  """ESE version used for setting up SupportAssist."""
  eseVersion: String @deprecated(reason: "Use status.eseVersion instead")
  """The ID of an object"""
  id: ID!
  """License type applied for this deployment of ObjectScale"""
  license: String @deprecated(reason: "Use licenseV2 resource")
  """Name of the SupportAssist resource"""
  name: String
  """The Kubernetes namespace in which the SupportAssist resource lies."""
  namespace: String
  """PIN used to register for the SupportAssist."""
  pin: String
  """
  The Spec field of SupportAssist displays the current settings, some can be modified by the user 
  """
  spec: Spec
  """The current status of the SupportAssist configuration."""
  status: Status
}

input UploadSignedPayloadInput {
  """SignedPayloadRequest from the Primary ObjectScale instance"""
  SignedPayload: String
}

input ToggleIAMAccountTSOInput {
  """An unique identifier for this account"""
  accountID: String!
  """Enable TSO for specific Iam account in secondary objScale site"""
  accountTSODisabled: Boolean!
}

"""The replication configuration rules for the replication configuration"""
type ReplicationRuleType {
  destination: ReplicationDestinationType
  filter: ReplicationFilterType
  id: String
  priority: Int
  status: String
}

"""A single workload contained within a given ObjectStore"""
input WorkloadInput {
  """Read write ratio"""
  readWriteRatio: Int
  """How much concurrent transactions"""
  transactions: Int
  """Use case for the object store"""
  useCase: UseCaseType
  """If data will be encrypted"""
  encryption: Boolean
  """Annual expected growth rate in percent for the store"""
  growthRate: Int
  """Object size for this workload"""
  objectSize: QuantityInput
  """Show how much capacity is needed"""
  primaryCapacity: QuantityInput
}

"""Settings for SupportAssist"""
type Spec {
  """CloudIQ settings for this ObjectScale deployment"""
  cloudIQ: cloudIQ
  """Enable/Disable SupportAssist"""
  enabled: Boolean
  """
  If set to true do not automatically open Service Requests on events to Dell
  """
  eventMuted: Boolean
  """List of one or more gateways configured for SupportAssist."""
  gateways: [Gateway]
  """Product name set for this SupportAssist configuration."""
  productName: String
  """Product type defined by SupportAssist."""
  productType: String
  """Product version currently set for this SupportAssist configuration"""
  productVersion: String
  """Enable/Disable remote access for SupportAssist."""
  remoteAccessEnabled: Boolean
  """
  This SiteID used to obtain the Access Key and PIN for this configuration.11
  """
  siteID: Int
  """The ObjectScale product system mode for SupportAssist."""
  systemMode: systemMode
  """Test connectivity back to Dell via SupportAssist."""
  testConnectivityID: Int
  """Test connectivity back to Dell via SupportAssist."""
  testDialHome: Boolean
  """Enable to use gateways for SupportAssist instead of direct connect"""
  useGateways: Boolean
}

"""An edge in a connection"""
type AccessKeyEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: AccessKey
}

"""An edge in a connection"""
type NonDeletedFederatedObjectStoreEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: FederatedObjectStore
}

"""Configuration specification for a component of an object-store"""
type ObjectStoreComponentSpec {
  """
  Indicates if the volumes provided for this component are considered highly-available without additional protection by the object-store. This field is returned objectscale-sizer.
  """
  highlyAvailableVolumes: Boolean
  """
  Number of replicas that should run for this component. This field is returned by objectscale-sizer.
  """
  replicas: Int
  """
  Storage capacity of the component volume. This field is returned by objectscale-sizer.
  """
  volumeCapacity: String
  """
  Number of volumes configured for the component. This field only applies to the storage server component
  """
  volumeCount: Int
  """Storage class to use for this component."""
  volumeStorageClassName: String
}

"""Fields sortable for remoteinstance"""
enum RemoteInstanceSortableField {
  objectScaleEndpoint
  objectScaleId
  objectScaleNamespace
  trustStatus
  type
  connectivityStatus
}

"""An edge in a connection"""
type LicenseV2Edge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: LicenseV2
}

input BucketUpdateInput {
  """the bucket size at which new object creations will be blocked"""
  blockSize: Int
  """the bucket size at which the users will be notified"""
  notificationSize: Int
  """The bucket policy to be applied"""
  policy: String
  """Versioning status of bucket"""
  enableVersioning: Boolean
}

"""IAM user used to manage object stores"""
type AttachedGroupUsers implements Node {
  """Amazon Resource Name of the user"""
  arn: String
  """Date on which this user was created"""
  createDate: DateTime
  """The ID of an object"""
  id: ID!
  """The last time a user performed a login or credential gated AWS action"""
  passwordLastUsed: String
  """The path to the user"""
  path: String
  """
  The ARN of the policy used to set the permissions boundary for the user
  """
  permissionsBoundary: PermissionBoundary
  """A list of tags that are associated with the specified user"""
  tags: [Tag]
  """The stable and unique string identifying the user"""
  userID: String
  """The friendly name identifying the user"""
  userName: String
}

"""A connection to a list of items."""
type AttachedPolicyEntityConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [AttachedPolicyEntityEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Fields sortable for kubernetes resources"""
enum KubernetesResourceSortableField {
  size
  readiness
  sizeResource
  kind
  name
  namespace
  creationTimestamp
}

"""The notification configuration set on the bucket"""
type NotificationConfigurationType {
  topicConfigurations: [TopicConfigurationType]
}

type ClusterNodesInput {
  """The allocatable resources within the cluster node"""
  allocatable: SizerClusterResourceType
  """The cluster node name"""
  name: String
}

"""Changes the sort order of nodes returned in a connection"""
input FedObjectStoreSort {
  """Name of field on which to sort the connection"""
  field: FedObjectStoreSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""A connection to a list of items."""
type IAMInlinePolicyConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [IAMInlinePolicyEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""the detached role policy to a resource"""
type DetachRolePolicyType {
  """Amazon Resource Name of the attached policy"""
  policyArn: String
  """The name of the user"""
  roleName: String
}

input IAMCreateGroupInput {
  """The name of the group to create"""
  groupName: String!
  """The path to the group"""
  path: String
  """The account where resource will be created"""
  accountID: String!
}

"""Changes the sort order of nodes returned in a connection"""
input EventSort {
  """Name of field on which to sort the connection"""
  field: EventSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""
A VMware StoragePool used to evaluate storage capacity resources by node and storage class
"""
input StoragePoolInput {
  """The amount of free space remaining in the pool in MiB"""
  freeSpaceInMiB: Int
  """List of storage classes compatible with this storage pool"""
  compatibleStorageClasses: [String]
  """Type of storage pool"""
  poolType: String
  """Unique name of the storage pool"""
  name: String
  """Names of all nodes in the cluster that can access this storage pool"""
  accessibleNodes: [String]
}

"""An edge in a connection"""
type GroupEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Group
}

"""Fields sortable for policy field"""
enum PolicySortableField {
  attachmentCount
  createDate
  defaultVersionID
  description
  isAttachable
  path
  updateDate
  ARN
  scope
  name
  policyID
  permissionsBoundaryUsageCount
}

"""Fields sortable for attached policy Entities"""
enum AttachedPolicyEntitySortableField {
  entityID
  entityName
  entityType
}

"""A connection to a list of items."""
type PolicyVersionsConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [PolicyVersionsEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A connection to a list of items."""
type NotifierConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [NotifierEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection"""
type KubernetesResourcesEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: KubernetesResourceNodeType
}

"""Kubernetes Container"""
type Container {
  """Container CPU Limit"""
  cpuLimit: Quantity
  """Container CPU Request in Millicores"""
  cpuLimitInMilli: Int
  """Container CPU Request"""
  cpuRequest: Quantity
  """Container CPU Requests in Millicores"""
  cpuRequestInMilli: Int
  """Container Image"""
  image: String
  """Container Memory Limit"""
  memoryLimit: Quantity
  """Container Memory Limit in Kilobytes"""
  memoryLimitInKB: Int
  """Container Memory Request"""
  memoryRequest: Quantity
  """Container Memory Request in Kilobytes"""
  memoryRequestInKB: Int
  """Container Name"""
  name: String
}

"""Changes the sort order of nodes returned in a connection"""
input UserSort {
  """Name of field on which to sort the connection"""
  field: UserSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""Specifies if replicates delete markers"""
input ReplicationStatusInputType {
  """Indicates whether to replicate delete markers"""
  status: String!
}

"""A connection to a list of items."""
type ClusterNodeConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [ClusterNodeEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Fields sortable for storage class field"""
enum StorageClassSortableField {
  driveTechnology
  name
  storagePoolTypes
  hostLocal
}

"""Names used to sign this certificate"""
type CertificateNamesTemplate {
  """Country of origin for certificate signer"""
  country: String
  """Locality of origin (city, town, county, etc.) for certificate signer"""
  locality: String
  """Organization signing this certificate"""
  organization: String
  """Organization unit (department) signing this certificate"""
  organizationalUnit: String
  """State or province of origin for certificate signer"""
  state: String
}

"""An edge in a connection"""
type SupportAssistEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: SupportAssist
}

"""A connection to a list of items."""
type UserConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [UserEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A connection to a list of items."""
type NonDeletedFederatedObjectStoreConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [NonDeletedFederatedObjectStoreEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Latency values in time points and aggregated latency value"""
type LatencyData {
  """Average latency value"""
  avg: Float
  """Latency values"""
  values: [latencyValue]
}

"""Field matcher to select events based for event rule"""
type MatchOn {
  """Field value for rule matcher"""
  field: String
  """Label value for rule matcher"""
  label: String
  """The operator that should be used in the match"""
  operator: String
  """Value that should be matched on"""
  value: String
}

"""Fields sortable for role field"""
enum RoleSortableField {
  description
  assumeRolePolicyDocument
  maxSessionDuration
  roleName
  roleID
  arn
  createDate
  path
  permissionsBoundary
}

type RootQuery {
  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
  """Returns the currently authenticated user"""
  viewer(namespace: String!): Viewer
}

"""Filter connection based comparison with int or int list argument"""
input FilterIntegerArgument {
  value: Int
  listValue: [Int]
  field: String
  operator: Operator
}

"""An ECS External DNS Endpoint"""
type ExternalDNSEndpoint {
  externalDNSEndpoint: String
}

"""reclaimPolicyType defines all available access mode for graphql."""
enum reclaimPolicyType {
  """
  PersistentVolumeReclaimRecycle means the volume will be recycled back into the poolof unbound persistent volumes on release from its claim. The volume plugin must support Recycling.
  """
  Recycle
  """
  PersistentVolumeReclaimDelete means the volume will be deleted from Kubernetes onrelease from its claim. The volume plugin must support Deletion.
  """
  Delete
  """
  PersistentVolumeReclaimRetain means the volume will be left in its current phase(Released) for manual reclamation by the administrator. The default policy is Retain.
  """
  Retain
}

"""Fields sortable for pod field"""
enum PodSortableField {
  namespace
  status
  CPURequest
  creationTimestamp
  readiness
  IP
  CPULimitInMilli
  name
  MemoryRequest
  CPURequestInMilli
  CPULimit
  node
  MemoryRequestInKB
  size
  MemoryLimit
  MemoryLimitInKB
}

"""Capacity information of the object store"""
type Capacity {
  """Data being processed of the object store as a quantity"""
  dataBeingProcessed: Quantity
  """Data being processed of the object store as a quantity"""
  dataBeingProcessedBase10: Quantity
  """Data being processed of the object store in megabytes"""
  dataBeingProcessedInMiB: Int
  """Data pending EC protection of the object store as a quantity"""
  dataPendingEcProtection: Quantity
  """Data pending EC protection of the object store as a quantity"""
  dataPendingEcProtectionBase10: Quantity
  """Data pending EC protection of the object store in megabytes"""
  dataPendingEcProtectionInMiB: Int
  """Number of days from now until the object store is full"""
  daysUntilFull: String
  """Available Capacity of the object store as a quantity"""
  free: Quantity
  """Available Capacity of the object store as a quantity"""
  freeBase10: Quantity
  """Available Capacity of the object store in megabytes"""
  freeInMiB: Int
  """Garbage Collected for system data of the object store as a quantity"""
  gcGarbageCollected: Quantity
  """
  Garbage Collected for system data of the object store as a base-10 storage quantity
  """
  gcGarbageCollectedBase10: Quantity
  """Garbage Reclaimed for system data of the object store as a quantity"""
  gcGarbageReclaimed: Quantity
  """
  Garbage Reclaimed for system data of the object store as a base-10 storage quantity
  """
  gcGarbageReclaimedBase10: Quantity
  """
  Un-reclaimable Garbage for system data of the object store as a quantity
  """
  gcMetadataUnreclaimable: Quantity
  """
  Un-reclaimable Garbage for system data of the object store as a quantity
  """
  gcMetadataUnreclaimableBase10: Quantity
  """
  Un-reclaimable Garbage for system data of the object store in megabytes
  """
  gcMetadataUnreclaimableInMiB: Int
  """
  Capacity Pending Reclamation for system data of the object store as a quantity
  """
  gcPendingMetadataReclaimable: Quantity
  """
  Capacity Pending Reclamation for system data of the object store as a quantity
  """
  gcPendingMetadataReclaimableBase10: Quantity
  """
  Capacity Pending Reclamation for system data of the object store in megabytes
  """
  gcPendingMetadataReclaimableInMiB: Int
  """
  Capacity Pending Reclamation for user data of the object store as a quantity
  """
  gcPendingUserDataReclaimable: Quantity
  """
  Capacity Pending Reclamation for user data of the object store as a quantity
  """
  gcPendingUserDataReclaimableBase10: Quantity
  """
  Capacity Pending Reclamation for user data of the object store in megabytes
  """
  gcPendingUserDataReclaimableInMiB: Int
  """Un-reclaimable Garbage for user data of the object store as a quantity"""
  gcUserDataUnreclaimable: Quantity
  """Un-reclaimable Garbage for user data of the object store as a quantity"""
  gcUserDataUnreclaimableBase10: Quantity
  """Un-reclaimable Garbage for user data of the object store in megabytes"""
  gcUserDataUnreclaimableInMiB: Int
  """System Metadata of the object store as a quantity"""
  metadata: Quantity
  """System Metadata of the object store as a quantity"""
  metadataBase10: Quantity
  """System Metadata of the object store in megabytes"""
  metadataInMiB: Int
  """Recovered offline data capacity of the object store as a quantity"""
  offlineRecovered: Quantity
  """Recovered offline data capacity of the object store as a quantity"""
  offlineRecoveredBase10: Quantity
  """Recovered offline data capacity of the object store in megabytes"""
  offlineRecoveredInMiB: Int
  """Unrecovered offline data capacity of the object store as a quantity"""
  offlineUnrecovered: Quantity
  """Unrecovered offline data capacity of the object store as a quantity"""
  offlineUnrecoveredBase10: Quantity
  """Unrecovered offline data capacity of the object store in megabytes"""
  offlineUnrecoveredInMiB: Int
  """Used Capacity of the object store in percent"""
  percentageFull: Float
  """Protection Overhead of the object store as a quantity"""
  protectionOverheadMetadata: Quantity
  """Protection Overhead of the object store as a quantity"""
  protectionOverheadMetadataBase10: Quantity
  """Protection Overhead of the object store in megabytes"""
  protectionOverheadMetadataInMiB: Int
  """Protection Overhead of the object store as a quantity"""
  protectionOverheadUserObject: Quantity
  """Protection Overhead of the object store as a quantity"""
  protectionOverheadUserObjectBase10: Quantity
  """Protection Overhead of the object store in megabytes"""
  protectionOverheadUserObjectInMiB: Int
  """Rate of data being erasure coded as a quantity"""
  rateOfECProtection: Quantity
  """Rate of data being erasure coded as a quantity"""
  rateOfECProtectionBase10: Quantity
  """Rate of data being erasure coded in megabytes"""
  rateOfECProtectionInMiB: Int
  """Reserved Capacity of the object store as a quantity"""
  reserved: Quantity
  """Reserved Capacity of the object store as a quantity"""
  reservedBase10: Quantity
  """Reserved Capacity of the object store in megabytes"""
  reservedInMiB: Int
  """Total Capacity of the object store as a quantity"""
  total: Quantity
  """Total Capacity of the object store as a quantity"""
  totalBase10: Quantity
  """Total Capacity of the object store in megabytes"""
  totalInMiB: Int
  """Used Capacity of the object store as a quantity"""
  totalInUsed: Quantity
  """Used Capacity of the object store as a quantity"""
  totalInUsedBase10: Quantity
  """Used Capacity of the object store in megabytes"""
  totalInUsedInMiB: Int
  """User Data of the object store as a quantity"""
  userData: Quantity
  """User Data of the object store as a quantity"""
  userDataBase10: Quantity
  """User Data of the object store as in megabytes"""
  userDataInMiB: Int
}

"""Fields sortable for user field"""
enum UserSortableField {
  createDate
  passwordLastUsed
  path
  permissionsBoundary
  tags
  userName
  userID
  arn
}

"""Fields sortable for objectstore field"""
enum ObjectStoreSortableField {
  name
  managementEndpoint
  replicas
  phase
  profile
  readyComponents
  namespace
  group
  managedBy
  s3SecureEndpoint
}

"""A connection to a list of items."""
type DeploymentConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [DeploymentEdge]
  filter: String
  isTruncated: Boolean
  maxBuckets: Int
  nextMarker: String
  nextPageLink: String
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Changes the sort order of nodes returned in a connection"""
input LicenseSortV2 {
  """Name of field on which to sort the connection"""
  field: LicenseSortableFieldV2
  """Direction to sort the connection"""
  direction: SortDirection
}

input GetWebhookConfigurationType {
  """Webhook urn (must be full URN not simple name)"""
  urn: String!
  """AccountID to use for the DCM mutation"""
  accountID: String!
}

input InitiateTrustInput {
  """The Objectscale ID"""
  objectScaleID: String
}

"""
Kubernetes workload resource settings to request or limit resources used on a node
"""
input WorkloadConfigResourceType {
  """Resource request for resource"""
  requests: [StringQuantityMapInputType]
  """Resource request for resource"""
  limits: [StringQuantityMapInputType]
}

"""Filter connection based comparison with string or string list argument"""
input FilterStringArgument {
  operator: Operator
  value: String
  listValue: [String]
  field: String
}

"""S3 credential secret key"""
type ObjectUserSecretKey {
  """Expiration date time of the secret key"""
  expiresAt: String
  """Value of the secret key"""
  value: String!
}

"""Configuration for ECS Flex manager log receiver"""
type LogReceiverConfig {
  """
  Indicates if the manager service should create a syslog based log receiver
  """
  autoCreate: Boolean
  """Network hostname of the log receiver endpoint"""
  hostname: String
  """Namespace and name of the log receiver"""
  namespacedName: NamespacedName
  """Network port of the log receiver endpoint"""
  port: Int
  """Network protocol of the log receiver endpoint"""
  protocol: NetworkProtocol
  """Storage capacity provisioned by the automatically created log receiver"""
  storageCapacity: Quantity
  """Storage class used by automatically created log receiver"""
  storageClass: String
  """Application type of the log receiver"""
  type: LogReceiverType
  """Workload configuration of a created log receiver"""
  workloadConfig: WorkloadConfig
}

"""Data protection scheme for object-store to protect user data"""
enum ErasureCodingSchemeType {
  """Ten-Two erasure-coding scheme"""
  TenTwo
  """No erasure-coding scheme"""
  NoErasureCodingScheme
  """Twelve-Four erasure-coding scheme"""
  TwelveFour
  """Six-Three erasure-coding scheme"""
  SixThree
  """Three-Three erasure-coding scheme"""
  ThreeThree
}

input IAMSAMLProviderUntagInput {
  """The ARN of the SAML provider"""
  arn: String
  """A list of key-value tags associated with the SAML provider"""
  tags: [TagInput]
}

"""An edge in a connection"""
type IAMGroupEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: IAMGroup
}

"""A key value pair in which the key is a string and value is a quantity"""
input StringQuantityMapInputType {
  """Quantity of infrastructure resource"""
  quantity: QuantityInput
  """Key used to select a Kubernetes resource"""
  key: String
}

"""Network protocol used for the log receiver"""
enum NetworkProtocolInputType {
  """UDP Protocol"""
  udp
  """HTTP Protocol"""
  http
  """HTTPS Protocol"""
  https
  """TCP Protocol"""
  tcp
}

"""Filter connection based comparison with string or string list argument"""
input FilterBooleanArgument {
  field: String
  operator: Operator
  value: Boolean
  listValue: [Boolean]
}

input ManagerConfigInput {
  """The config of Manager"""
  managerConfig: ManagerConfigInputType
}

input DefaultEventRuleUpdateInput {
  """Name of the event rule to be updated"""
  eventRuleIdentifier: Int!
  """The eventRule to be created"""
  eventRule: EventRuleInputType!
}

"""Detailed results of a given healthcheck container"""
type HealthCheckStatus {
  """End time of health check container"""
  endTime: DateTime
  """Results of each health check within the container"""
  results: [HealthCheckResults]
  """Start time of health check container"""
  startTime: DateTime
  """
  Top level status of health check container. If any subchecks fail, this will fail
  """
  status: String
}

"""An edge in a connection"""
type StoragePoolEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: StoragePool
}

"""Kubernetes Pod"""
type Pod implements Node & KubernetesResource {
  """Pod CPU Limit"""
  CPULimit: Quantity
  """Pod CPU Limit in Millicores"""
  CPULimitInMilli: Int
  """Pod CPU Request"""
  CPURequest: Quantity
  """Pod CPU Request in Millicores"""
  CPURequestInMilli: Int
  """Pod IP address"""
  IP: String
  """Pod Memory Limit"""
  MemoryLimit: Quantity
  """Pod Memory Limit in Kilobytes"""
  MemoryLimitInKB: Int
  """Pod Memory Request"""
  MemoryRequest: Quantity
  """Pod Memory Request in Kilobytes"""
  MemoryRequestInKB: Int
  """Containers in this Pod"""
  containers: [Container]
  creationTimestamp: String
  """The ID of an object"""
  id: ID!
  kind: String
  """Pod Name"""
  name: String
  """Pod Namespace"""
  namespace: String
  """Pod Node"""
  node: String
  readiness: String
  size: Quantity
  sizeResource: String
  """Pod Status"""
  status: String
}

input ApproveCertificateRequestInput {
  """Name and namespace of the application the certificate applies to"""
  applicationName: NamespacedNameInput
  """The certificate to approve"""
  certificateRequestName: String
}

"""An edge in a connection"""
type StorageClassEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: StorageClass
}

"""A legal hold configuration from a bucket item.."""
type LegalHoldConfiguration {
  legalHold: Boolean
}

"""A connection to a list of items."""
type AccountAccessKeyConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [AccountAccessKeyEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""Network connection details for resource"""
input NetworkConnectionInput {
  """List of hostnames applied to this connection"""
  externalHostnames: [String]
  """Certificate files for this connection"""
  certificate: CertificateInput
  """Kubernetes service type of the connection"""
  serviceType: ServiceServiceType!
  """Type of certificate signing procedure to use for the connection"""
  certificateType: CertificateSigningType!
  """The load balancer IP address of the connection"""
  loadBalancerIP: String
  """The node port address of the connection"""
  nodePort: Int
  """List of external IP addresses applied to this connection"""
  externalIPAddresses: [String]
  """Certificate signing request for this connection"""
  certificateSigningRequest: CertificateSigningRequestInput
  """Indicates if this connection should use the manager certificate"""
  inheritFromManager: Boolean
  """
  Configure expiry notification to be sent this number of days before the certificate expires
  """
  expiryNotificationTime: Int
}

"""SRS Gateway Input Type"""
input SRSGatewayInputType {
  """SRS Gateway host"""
  srsGatewayHost: String
  """SRS Gateway port"""
  srsGatewayPort: Int
  """Remote Access external IP"""
  remoteAccessExternalIP: String
  """Remote Access username"""
  remoteAccessUsername: String
  """Remote Access user password"""
  remoteAccessPassword: String
  """Namespaced name in which this SRS Gateway resides"""
  objectStore: NamespacedNameInput
  """SRS Gateway username"""
  srsGatewayUsername: String
  """SRS Gateway user password"""
  srsGatewayPassword: String
}

"""Changes the sort order of nodes returned in a connection"""
input DeploymentSort {
  """Name of field on which to sort the connection"""
  field: DeploymentSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""An edge in a connection"""
type NodeLabelEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: ClusterLabel
}

"""
CloudIQ settings for enabling/disable CloudIQ reporting and each reports frequency
"""
type cloudIQ {
  """ Frequency of the capacity report in minutes"""
  capacityFrequency: Int
  """Flag to turn on/off CloudIQ reporting"""
  enabled: Boolean
  """Frequency of the health report in minutes"""
  healthFrequency: Int
  """Frequency of the inventory report in minutes"""
  inventoryFrequency: Int
  """Frequency of the performance report in minutes"""
  performanceFrequency: Int
  """Frequency of the usage intelligence report in minutes."""
  usageIntelligenceFrequency: Int
}

"""Configuration for DECKS application"""
type DECKSConfig {
  """DECKS workload config"""
  decksWorkloadConfig: WorkloadConfig
  """Indicates if DECKS is enabled for this install"""
  enabled: Boolean
  """Event rules applied to events emitted from DECKS application"""
  eventRules: [EventRule]
  """Namespace and name of kubernetes application resource"""
  namespacedName: NamespacedName
  """Test SRS Gateway"""
  testSRSGateway: SRSGateway
  """DECKS version"""
  version: String
}

"""Root field of the schema"""
type Viewer {
  """Return a list of Accounts"""
  accounts(
    createDate: FilterDateTimeArgument
    encryptionEnabled: FilterBooleanArgument
    alias: FilterStringArgument
    offset: Int
    first: Int
    """Deprecated in favor of new field accountID"""
    AccountId: FilterStringArgument
    """Deprecated in favor of new field encryptionEnabled"""
    EncryptionEnabled: FilterStringArgument
    """Deprecated in favor of new field alias"""
    Alias: FilterStringArgument
    last: Int
    before: String
    """Deprecated in favor of new field createDate"""
    CreateDate: FilterDateTimeArgument
    """Deprecated in favor of new field description"""
    Description: FilterStringArgument
    complianceEnabled: FilterBooleanArgument
    sort: AccountSort
    """Deprecated in favor of new field objectscale"""
    Objectscale: FilterStringArgument
    objectscale: FilterStringArgument
    description: FilterStringArgument
    """Deprecated in favor of new field complianceEnabled"""
    ComplianceEnabled: FilterStringArgument
    accountID: FilterStringArgument
    after: String
  ): AccountConnection
  """Token details for the currently authenticated user"""
  authenticatedUser: AuthenticatedUser
  """Returns Object Scale level capacity metrics"""
  capacity: Capacity
  certificateAuthorityBundle: String
  """Returns a list of cluster nodes"""
  clusterNodes(
    available: FilterBooleanArgument
    """The key of the label"""
    key: String
    offset: Int
    before: String
    role: FilterStringArgument
    """The fault domain key"""
    faultDomainKey: String
    after: String
    name: FilterStringArgument
    """The source of the label"""
    source: String
    first: Int
    """The value of the label"""
    value: String
    """The fault domain source"""
    faultDomainSource: String
    """
    List of node hostnames (kubernetes.io/hostname label) to be excluded from resource scheduling
    """
    excludedNodes: [String]
    sort: ClusterNodeSort
    last: Int
  ): ClusterNodeConnection
  """A list of drive technologies available in the system. (HDD, SSD etc.)"""
  compatibileDriveTechnologies: [String]
  """Configuration of the Dell EMC Common Kubernetes Services"""
  decksConfig: DECKSConfig
  """
  Indicates whether the Dell EMC Common Kubernetes Services (DECKS) platform is enabled
  """
  decksEnabled: Boolean
  """Return a list events"""
  events(component: FilterStringArgument, reason: FilterStringArgument, applicationName: FilterStringArgument, resourceID: FilterStringArgument, offset: Int, after: String, symptomID: FilterStringArgument, message: FilterStringArgument, updatedOn: FilterDateTimeArgument, count: Int, sort: EventSort, before: String, first: Int, last: Int, type: FilterStringArgument, createdOn: FilterDateTimeArgument, namespace: FilterStringArgument, acknowledged: FilterBooleanArgument): EventConnection
  """Returns External Connection Info"""
  externalConnection: NetworkConnection
  """Returns a list of fed ObjectStores"""
  fedObjectStores(initialized: FilterStringArgument, creationTimestamp: FilterStringArgument, offset: Int, last: Int, objectStoreId: FilterStringArgument, apiVersion: FilterStringArgument, status: FilterStringArgument, uid: FilterStringArgument, sort: FedObjectStoreSort, after: String, first: Int, k8sNamespace: FilterStringArgument, version: FilterStringArgument, deleted: FilterBooleanArgument, objectScaleId: FilterStringArgument, objectStoreName: FilterStringArgument, before: String): FedObjectStoreConnection
  """Returns Federation Signing Request"""
  federationSigning: String
  """
  Generates a log bundle for the manager components, and returns a URL to download
  """
  generateManagerLogBundle: String
  """Returns the K8S user login token for Grafana Access"""
  grafanaUserToken(inputs: NamespaceAccessListDetailsInput!): String
  """
  Returns a list of groups assigned to object store Application resources
  """
  groups(last: Int, name: FilterStringArgument, offset: Int, sort: GroupSort, before: String, after: String, first: Int): GroupConnection
  """Returns a list of HealthChecks"""
  healthChecks(after: String, first: Int, last: Int, name: FilterStringArgument, namespace: FilterStringArgument, check: String, offset: Int, before: String): HealthCheckConnection
  """Returns a list of Kubernetes HelmCharts"""
  helmCharts(type: FilterStringArgument, first: Int, apiVersion: FilterStringArgument, condition: FilterStringArgument, appVersion: FilterStringArgument, kubeVersion: FilterStringArgument, offset: Int, name: FilterStringArgument, sources: FilterStringListArgument, keywords: FilterStringListArgument, sort: HelmChartSort, after: String, last: Int, home: FilterStringArgument, version: FilterStringArgument, deprecated: FilterBooleanArgument, allVersions: Boolean, before: String, description: FilterStringArgument, icon: FilterStringArgument, tags: FilterStringArgument): HelmChartConnection
  """Returns a list of Helm releases installed to a Kubernetes cluster"""
  helmReleases(name: FilterStringArgument, before: String, after: String, chartName: FilterStringArgument, lastDeployed: FilterDateTimeArgument, all: Boolean, kahmSubscribed: FilterBooleanArgument, offset: Int, sort: HelmReleaseSort, last: Int, first: Int, namespace: FilterStringArgument, chartVersion: FilterStringArgument, status: FilterStringArgument): HelmReleaseConnection
  """The ID of an object"""
  id: ID!
  isHotfixed(
    """version the component is attempting to upgrade to"""
    toVersion: String!
  ): Boolean
  """Return a list application health issues"""
  issues(applicationName: FilterStringArgument, offset: Int, after: String, createdOn: FilterDateTimeArgument, updatedOn: FilterDateTimeArgument, last: Int, sort: IssueSort, component: FilterStringArgument, message: FilterStringArgument, namespace: FilterStringArgument, resourceID: FilterStringArgument, reason: FilterStringArgument, acknowledged: FilterBooleanArgument, before: String, first: Int, symptomID: FilterStringArgument, type: FilterStringArgument, clearType: FilterStringArgument): IssueConnection
  """Checks to determine the health of Kubernetes Applications"""
  kahmConfig: KAHMConfigTypeName
  """Returns a list of label for node"""
  labels(source: FilterStringArgument, key: FilterStringArgument, value: FilterStringArgument, offset: Int, last: Int, sort: ClusterNodeSort, before: String, after: String, first: Int): NodeLabelConnection
  """Returns Object Scale level latency metrics"""
  latency(
    """Frame start time for performance data selection (RFC 3339 format)"""
    start: DateTime
    """Frame end time for performance data selection (RFC 3339 format)"""
    end: DateTime
  ): Latency
  """Return a list of Licenses"""
  licenses(startDate: FilterDateTimeArgument, name: FilterStringArgument, endDate: FilterDateTimeArgument, sort: LicenseSort, first: Int, quantity: FilterStringArgument, type: FilterStringArgument, gracePeriod: FilterStringArgument, offset: Int, after: String, namespace: FilterStringArgument, enterpriseSoftwareID: FilterStringArgument, instanceSoftwareID: FilterStringArgument, before: String, last: Int): LicenseConnection
  """License connectivity for ObjectScale"""
  licensesV2(first: Int, enterpriseSoftwareID: FilterStringArgument, offset: Int, last: Int, before: String, after: String, name: FilterStringArgument, namespace: FilterStringArgument, instanceSoftwareID: FilterStringArgument, sort: LicenseSortV2): LicenseV2Connection
  """Configuration of the ECS Flex Manager application"""
  managerConfig: ManagerConfig
  managerHealth: String
  """Returns the management service OS TOKEN"""
  managerToken: String
  """Returns metadata for a service provider"""
  metadata: String
  """Returns bucket and object level statistics for the object scale"""
  metering(
    """TenantID used to identify the bucket namespace"""
    tenantID: String
  ): Metering
  """Returns a list of Kubernetes namespaces"""
  namespaces(sort: NamespaceSort, first: Int, last: Int, before: String, after: String, name: FilterStringArgument, offset: Int): NamespaceConnection
  """Return a list of Notifiers"""
  notifiers(port: FilterIntegerArgument, GRPCConnTimeout: FilterIntegerArgument, GRPCRetries: FilterIntegerArgument, before: String, after: String, sort: NotifierSort, first: Int, last: Int, name: FilterStringArgument, hostname: FilterStringArgument, TotalEventsDelivered: FilterIntegerArgument, Available: FilterBooleanArgument, offset: Int): NotifierConnection
  """Returns information about ObjectScale instances"""
  objectScaleInfo: ObjectScaleInfo
  objectStoreUpgradesAvailable: Boolean @deprecated(reason: "Please use upgradesavailable on the objectstore connection instead of the viewer to determine upgrade status.")
  objectStoreVersions: [String]
  """Returns a list of ObjectStores"""
  objectStores(
    last: Int
    after: String
    name: FilterStringArgument
    managedBy: FilterStringArgument
    namespace: FilterStringArgument
    """The number of storage instances used in an object store"""
    replicas: FilterIntegerArgument
    first: Int
    before: String
    group: FilterStringArgument
    phase: FilterStringArgument
    """
    Object store profile used for to attain capacity, concurrency and/orperformance requirements
    """
    profile: FilterStringArgument
    offset: Int
    sort: ObjectStoreSort
  ): ObjectStoreConnection
  """Return a list of object store templates"""
  objectstoretemplates(after: String, name: FilterStringArgument, offset: Int, sort: ObjectStoreTemplateSort, first: Int, last: Int, before: String): ObjectStoreTemplateConnection
  """Returns a list of Kubernetes persistent volume claims"""
  persistentVolumeClaims(volumeName: FilterStringArgument, storageClassName: FilterStringArgument, name: FilterStringArgument, capacityInMB: FilterIntegerArgument, sort: PersistentVolumeClaimSort, before: String, after: String, first: Int, last: Int, volumeMode: FilterStringArgument, offset: Int): PersistentVolumeClaimConnection
  """Return a list of Kubernetes persistent volumes"""
  persistentVolumes(last: Int, status: FilterStringArgument, storageClassName: FilterStringArgument, offset: Int, capacity: FilterStringArgument, reclaimPolicy: FilterStringArgument, createdTimestamp: FilterDateTimeArgument, first: Int, name: FilterStringArgument, claimName: FilterStringArgument, message: FilterStringArgument, after: String, reason: FilterStringArgument, sort: PersistentVolumeSort, before: String): PersistentVolumeConnection
  """Returns a list of ObjectScale remote instances"""
  remoteInstances(sort: RemoteInstanceSort, before: String, after: String, objectScaleId: FilterStringArgument, objectScaleNamespace: FilterStringArgument, connectivityStatus: FilterStringArgument, offset: Int, first: Int, last: Int, objectScaleEndpoint: FilterStringArgument, trustStatus: FilterStringArgument, type: FilterStringArgument): RemoteInstanceConnection
  requestSizing(inputs: SizingInputTypeInput!, objectStoreName: String): SizingResult
  """Provisioned resource for this object store"""
  resources: ResourceProvision
  """Returns Policy Editor JSON Metadata from ObjectControl Service"""
  serviceMetaData: String
  """Returns service provider"""
  serviceprovider: ServiceProvider
  """Return a list of SRS Gateways"""
  srsGateways(gatewayPassword: FilterStringArgument, gatewaySerialNumber: FilterStringArgument, last: Int, gatewayPort: FilterIntegerArgument, serialNumber: FilterStringArgument, disabled: FilterBooleanArgument, after: String, remoteAccessExternalIP: FilterStringArgument, registered: FilterBooleanArgument, testDialHomeTime: FilterDateTimeArgument, sort: SRSGatewaySort, before: String, offset: Int, gatewayUsername: FilterStringArgument, gatewayHost: FilterStringArgument, remoteAccessUsername: FilterStringArgument, remoteAccessPassword: FilterStringArgument, testDialHomeResult: FilterStringArgument, reconcileError: FilterStringArgument, state: FilterStringArgument, first: Int): SRSGatewayConnection
  """Returns a list of possible states of an object store"""
  states: [StateType]
  """Returns a list of Kubernetes storage classes"""
  storageClasses(hostLocal: FilterBooleanArgument, offset: Int, before: String, first: Int, last: Int, name: FilterStringArgument, driveTechnology: FilterStringArgument, filterByResourceQuota: Boolean, sort: StorageClassSort, after: String, storagePoolTypes: FilterStringListArgument): StorageClassConnection
  """
  Returns the details of how much storage is consumed from the available space
  """
  storageConsumed: StorageConsumedType
  """Returns a list of Kubernetes StoragePolicies"""
  storagePolicies(namespace: FilterStringArgument, before: String, after: String, first: Int, last: Int, name: FilterStringArgument, reconcileStatus: FilterStringArgument, storagePolicyID: FilterStringArgument, storagePolicyName: FilterStringArgument, offset: Int, sort: StoragePoliciesSort): StoragePolicyConnection
  """Returns a list of Kubernetes StoragePools"""
  storagePools(name: FilterStringArgument, totalCapacityInMiB: FilterIntegerArgument, before: String, after: String, first: Int, last: Int, dataStoreURL: FilterStringArgument, accessibleNodes: FilterStringArgument, compatibleStorageClasses: FilterStringListArgument, freeSpaceInMiB: FilterIntegerArgument, errorState: FilterStringListArgument, errorMessage: FilterStringArgument, offset: Int, poolType: FilterStringArgument, sort: StoragePoolSort): StoragePoolConnection
  """SupportAssist connectivity for ObjectScale"""
  supportAssist(before: String, name: FilterStringArgument, namespace: FilterStringArgument, after: String, first: Int, last: Int): SupportAssistConnection
  """Returns the Total Used Capacity for all Object Stores in GiB"""
  totalUsedCapacity: Quantity
  """Returns a list of trusted anchors"""
  trustedAnchors: TrustedAnchorsConnection
  """Resource utilization metrics for this object store"""
  usage: ResourceUsage
  """Webhook Configuration for a given account"""
  webhookConfiguration(input: GetWebhookConfigurationType!): Webhook
}

"""
persistentVolumePhaseType defines all available access mode for graphql.
"""
enum persistentVolumePhaseType {
  """Used for PersistentVolumes that are bound."""
  Bound
  """
  Used for PersistentVolumes where the bound PersistentVolumeClaim was deleted.Released volumes must be recycled before becoming available again. This phase is used by thepersistent volume claim binder to signal to another process to reclaim the resource
  """
  Released
  """
  Used for PersistentVolumes that failed to be correctly recycled or deleted afterbeing released from a claim.
  """
  Failed
  """Used for PersistentVolumes that are not available."""
  Pending
  """
  Used for PersistentVolumes that are not yet bound. Available volumes are held bythe binder and matched to PersistentVolumeClaims.
  """
  Available
}

"""A key value pair in which the key and value are both strings"""
type StringMap {
  """Key used to select a Kubernetes resource"""
  key: String
  """Value used to select a Kubernetes resource"""
  value: String
}

"""A pod affinity rule used in affinity or anti-affinity definitions"""
input AffinityTermInputType {
  """Selector used to affinitize or anti-affinitize this pod to other pods"""
  labelSelector: LabelSelectorTypeInputType
  """
  Node label used to identify specific groups of nodes for affinity or anti-affinity
  """
  topologyKey: String
}

"""Add IAM user to specific IAM group"""
input AddUserToGroupInput {
  """The account ID of the user"""
  accountID: String!
  """The friendly name identifying the user"""
  userName: String!
  """The name of the group to add"""
  groupName: String!
}

input EventRuleUpdateInput {
  """Name of the eventrule and namespace it resides in"""
  application: NamespacedNameInput!
  """Name of the event rule to be updated"""
  eventRuleIdentifier: Int!
  """The eventRule to be created"""
  eventRule: EventRuleInputType!
}

"""A reference to a Kubernetes object type"""
type LocalObjectReference {
  apiGroup: String
  kind: String
  name: String
}

"""The IAM Inline Policy structure"""
type IAMInlinePolicy implements Node {
  """The ID of an object"""
  id: ID!
  """The policy document"""
  policyDocument: String
  """The name of the policy"""
  policyName: String
}

"""An federation trust Info type"""
type TrustedAnchors implements Node {
  """The ID of an object"""
  id: ID!
  key: String
  value: String
}

input AttachIAMUserPolicyInput {
  """The name of the policy to attach to the user"""
  policyArn: String!
  """The account id of the user"""
  accountID: String!
  """The name of the user to attach the policy"""
  userName: String!
}

input CreateServiceProviderInput {
  create_time: String
  java_keystore: String!
  key_alias: String!
  key_password: String!
  dns: String!
  unique_id: String
  uuid: String
}

"""Fields sortable for fed ObjectStores"""
enum FedObjectStoreSortableField {
  objectScaleId
  creationTimestamp
  initialized
  uid
  objectStoreId
  k8sNamespace
  objectStoreName
  apiVersion
  version
  status
  deleted
}

"""Fields sortable for account field"""
enum AccountSortableField {
  objectscale
  createDate
  encryptionEnabled
  complianceEnabled
  alias
  description
  accountID
}

"""A connection to a list of items."""
type RemoteInstanceConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [RemoteInstanceEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge in a connection"""
type AccountEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Account
}

"""Field matcher to select events based for event rule"""
input MatchOnInput {
  """Field value for rule matcher"""
  field: String
  """Label value for rule matcher"""
  label: String
  """Value that should be matched on"""
  value: String
  """The operator that should be used in the match"""
  operator: String
}

"""An edge in a connection"""
type NotifierEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: Notifier
}

"""Type of Kubernetes service"""
enum ServiceServiceType {
  LoadBalancer
  ClusterIP
  NodePort
}

"""Entity Types which can attached to a Policy"""
enum PolicyEntityType {
  """Policy is Associated to a Role"""
  Role
  """Policy is Associated to a Group"""
  Group
  """Policy is Associated to a User"""
  User
}

input ObjectStoreBulkActionInput {
  """Namespaces and names of object-stores upon which to perform operation"""
  namespacedNames: [NamespacedNameInput]
}

"""An edge in a connection"""
type ClusterNodeEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: ClusterNode
}

"""A service provider info type"""
type ServiceProvider {
  create_time: String
  dns: String
  java_keystore: String
  key_alias: String
  key_password: String
  unique_id: String
  uuid: String
}

"""Changes the sort order of nodes returned in a connection"""
input ObjectStoreTemplateSort {
  """Name of field on which to sort the connection"""
  field: ObjectStoreTemplateSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

"""The input required to delete a Tenant's quota."""
input DeleteTenantQuotaInput {
  objectStore: NamespacedNameInput
  accountID: String
}

"""A kubernetes resource"""
type KubernetesResourceNodeType implements Node {
  creationTimestamp: String
  id: ID!
  kind: String
  name: String
  namespace: String
  """
  Service readiness as a permille (a percentage with a base of 1000 instead of 100)
  """
  readiness: Int
  size: Quantity
  sizeResource: String
}

"""Changes the sort order of nodes returned in a connection"""
input PersistentVolumeClaimSort {
  """Name of field on which to sort the connection"""
  field: PersistentVolumeClaimSortableField
  """Direction to sort the connection"""
  direction: SortDirection
}

enum IssueClearTypes {
  Manual
  Auto
}

"""Changes the sort order of nodes returned in a connection"""
input LicenseSort {
  """Direction to sort the connection"""
  direction: SortDirection
  """Name of field on which to sort the connection"""
  field: LicenseSortableField
}

"""An edge in a connection"""
type AttachedPolicyEntityEdge {
  """ cursor for use in pagination"""
  cursor: String!
  """The item at the end of the edge"""
  node: AttachedPolicyEntity
}

"""Storage topology details for resource"""
input StorageTopologyInput {
  """The topology spread and fault domain key"""
  faultDomainKey: String
  """The disallowed fault domains for resource scheduling"""
  excludedFaultDomains: [String]
  """
  List of node hostnames (kubernetes.io/hostname label) to be excluded from resource scheduling
  """
  excludedNodes: [String]
}

"""A connection to a list of items."""
type PersistentVolumeConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The field name for the summation"""
    values: [String]
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [PersistentVolumeEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""A connection to a list of items."""
type KubernetesResourcesConnection {
  """Count and summarize for each defined grouping"""
  aggregations(
    """The aggregation function to use. Currently support sum or count"""
    function: ConnectionAggregationFunction
    """The field name to group the value"""
    groups: [String]
    """The field name for the summation"""
    values: [String]
  ): ConnectionAggregation
  """Summarized counts for each defined grouping"""
  counts(groups: [String]): Counts
  """Information to aid in pagination."""
  edges: [KubernetesResourcesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""
The replication configuration filter for the replication configuration rule
"""
type ReplicationFilterType {
  prefix: String
  tag: [ReplicationTagType]
}

"""The node selector where resources should be targed for scheduling"""
type NodeSelectionInputType {
  """The key of node labels to determine selection"""
  key: String
  """The source of node labels to determine selection"""
  source: String
  """The value of node labels to determine selection"""
  value: String
}

"""FeatureV2"""
type FeatureV2 {
  """The date when the license expires"""
  endDate: String
  """The date the license can be renewed after expiring"""
  gracePeriod: String
  """Name of the licensed feature"""
  name: String
  """Product line from the License"""
  productLine: String
  """Quantity available for this feature"""
  quantity: Int
  """The date from when the license will be valid"""
  startDate: String
  """License type of this feature"""
  type: String
  """Unit of measurement code for this feature"""
  uomCode: String
  """Unit of measurement name for this feature"""
  uomName: String
  """Current usage amount used by this feature"""
  usage: Int
}

"""Fields sortable for attached policy field"""
enum AttachedPolicySortableField {
  policyArn
  policyName
}

input DeleteIAMGroupPolicyInput {
  """The name of the policy document"""
  policyName: String!
  """The account where resource created"""
  accountID: String!
  """The name of the group to delete"""
  groupName: String!
}

"""Hosts signed by a certificate"""
type CertificateHosts {
  """DNS names that are signed with this certificate"""
  dns: [String]
  """IP addresses that are signed with this certificate"""
  ip: [String]
}

"""IAM user used to manage object stores"""
type User implements Node {
  """Return a list of Access Keys"""
  accessKeys(createDate: FilterDateTimeArgument, status: FilterStringArgument, userName: FilterStringArgument, lastUsedDate: FilterDateTimeArgument, sort: AccessKeySort, before: String, last: Int, offset: Int, after: String, first: Int): AccessKeyConnection
  """Amazon Resource Name of the user"""
  arn: String
  """Return a list of Policies attached to a resource"""
  attachedPolicies(last: Int, policyArn: FilterStringArgument, policyName: FilterStringArgument, offset: Int, sort: AttachedPolicySort, before: String, after: String, first: Int): AttachedPolicyConnection
  """Date on which this user was created"""
  createDate: DateTime
  """Return a list of group for a user"""
  groups(
    before: String
    first: Int
    """The path to the group"""
    path: FilterStringArgument
    """
    The date and time, in ISO 8601 date-time format, when the group was created
    """
    createDate: FilterDateTimeArgument
    """The stable and unique string identifying the group"""
    groupID: FilterStringArgument
    """The friendly name that identifies the group"""
    groupName: FilterStringArgument
    offset: Int
    sort: IAMGroupSort
    after: String
    last: Int
    """The Amazon Resource Name (ARN) specifying the group"""
    arn: FilterStringArgument
  ): IAMListGroupForUserConnection
  """The ID of an object"""
  id: ID!
  """Return a list of inline policies"""
  inlinePolicies(last: Int, policyName: FilterStringArgument, policyDocument: FilterStringArgument, offset: Int, sort: InlinePolicySort, before: String, after: String, first: Int): IAMInlinePolicyConnection
  """The last time a user performed a login or credential gated AWS action"""
  passwordLastUsed: String
  """The path to the user"""
  path: String
  """
  The ARN of the policy used to set the permissions boundary for the user
  """
  permissionsBoundary: PermissionBoundary
  """A list of tags that are associated with the specified user"""
  tags: [Tag]
  """The stable and unique string identifying the user"""
  userID: String
  """The friendly name identifying the user"""
  userName: String
}

input IAMCreateAccountInput {
  """A longer text description of this account"""
  description: String
  """A root user for this account"""
  accountRootUser: String
  """Root password used for this account"""
  accountRootPassword: String
  """Confirmed root password used for this account"""
  accountRootConfirmPassword: String
  """A simple name used for this account"""
  alias: String!
  """Deprecated in favor of new alias field"""
  Alias: String
  """Boolean value indicates if encryption is enabled for this account"""
  encryptionEnabled: Boolean
  """Boolean value indicates if compliance is enabled for this account"""
  complianceEnabled: Boolean
}